{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pytest-cases \u00b6 Separate test code from test cases in pytest . Brand new v2, check the changes ! Installing pytest-cases has effects on the order of pytest tests execution. Details here Did you ever think that most of your test functions were actually the same test code , but with different data inputs and expected results/exceptions ? pytest-cases leverages pytest and its great @pytest.mark.parametrize decorator, so that you can separate your test cases from your test functions . In addition, pytest-cases improves pytest 's fixture mechanism to support \"fixture unions\". This is a major change in the internal pytest engine, unlocking many possibilities such as using fixture references as parameter values in a test function. See here . pytest-cases is fully compliant with pytest-harvest so you can easily monitor the execution times and created artifacts. With it, it becomes very easy to create a complete data science benchmark, for example comparing various models on various datasets as illustrated below (from the example section): Installing \u00b6 > pip install pytest_cases Note: Installing pytest-cases has effects on the order of pytest tests execution, even if you do not use its features. One positive side effect is that it fixed pytest#5054 . But if you see less desirable ordering please report it . Why pytest-cases ? \u00b6 pytest philosophy Let's consider the following foo function under test, located in example.py : def foo ( a , b ): return a + 1 , b + 1 If we were using plain pytest to test it with various inputs, we would create a test_foo.py file and use @pytest.mark.parametrize : import pytest from example import foo @pytest . mark . parametrize ( \"a,b\" , [( 1 , 2 ), ( - 1 , - 2 )]) def test_foo ( a , b ): # check that foo runs correctly and that the result is a tuple. assert isinstance ( foo ( a , b ), tuple ) This is the fastest and most compact thing to do when you have a few number of test cases, that do not require code to generate each test case. pytest current limitations Now imagine that instead of (1, 2) and (-1, -2) each of our test cases requires a few lines of code to be generated. For example artificial data creation using numpy and/or pandas : import numpy as np import pandas as pd # case 1: non-sorted uniformly sampled timeseries with 2 holes case1 = pd . DataFrame ({ \"datetime\" : pd . date_range ( start = '20/1/1' , periods = 20 , freq = '-1d' , tz = 'UTC' ), \"data1\" : np . arange ( 0 , 20 ), \"data2\" : np . arange ( 1 , 21 ), \"data3\" : np . arange ( 1 , 21 )}) case1 . drop ([ 3 , 12 ], inplace = True ) requires documentation to explain the other developers the intent of that precise test case requires external resources (data files on the filesystem, databases...), with a variable number of cases depending on what is available on the resource - but of course not all the cases would come from the same resource, that would be too easy :). requires a readable id , such as 'uniformly_sampled_nonsorted_with_holes' for the above example. Of course we could use pytest.param or ids=<list> but that is \"a pain to maintain\" according to pytest doc (I agree!). Such a design does not feel right as the id is detached from the case. With standard pytest there is no particular pattern to simplify your life here. Investigating a little bit, people usually end up trying to mix parameters and fixtures and asking this kind of question: so1 , so2 . But by design it is not possible to solve this problem using fixtures, because pytest does not handle \"unions\" of fixtures . So all in all, the final answer is \"you have to do this yourself\", and have pytest use your handcrafted list of parameters as the list of argvalues in @pytest.mark.parametrize . Typically we would end up creating a get_all_foo_test_cases function, independently from pytest : @pytest . mark . parametrize ( \"a,b\" , get_all_foo_test_cases ()) def test_foo ( a , b ): ... There is also an example in pytest doc with a metafunc hook . The issue with such workarounds is that you can do anything . And anything is a bit too much: this does not provide any convention / \"good practice\" on how to organize test cases, which is an open door to developing ad-hoc unreadable or unmaintainable solutions. pytest_cases was created to provide an answer to this precise situation. It proposes a simple framework to separate test cases from test functions. The test cases are typically located in a separate \"companion\" file: test_foo.py is your usual test file containing the test functions (named test_<id> ), test_foo_cases.py contains the test cases , that are also functions (named case_<id> or even <prefix>_<id> if you prefer). Note: an alternate file naming style cases_foo.py is also available if you prefer it. Test cases can also be provided explicitly, for example in a class container: And many more as we'll see below . Basic usage \u00b6 a- Case functions \u00b6 Let's create a test_foo_cases.py file. This file will contain test cases generator functions , that we will call case functions for brevity. In these functions, you will typically either parse some test data files, generate some simulated test data, expected results, etc. def case_two_positive_ints (): \"\"\" Inputs are two positive integers \"\"\" return 1 , 2 def case_two_negative_ints (): \"\"\" Inputs are two negative integers \"\"\" return - 1 , - 2 Case functions do not have any particular requirement , apart from the default name convention case_<id> - but even that can be customized: you can use distinct prefixes to denote distinct kind of parameters, such as data_<id> , user_<id> , model_<id> ... Case functions can return anything that is considered useful to run the associated test. We will see below that you can use all classic pytest mechanism on case functions (id customization, skip/fail marks, parametrization, fixtures injection). b- Test functions \u00b6 As usual we write our pytest test functions starting with test_ , in a test_foo.py file. The only difference is that we now decorate it with @parametrize_with_cases instead of @pytest.mark.parametrize as we were doing previously : from example import foo from pytest_cases import parametrize_with_cases @parametrize_with_cases ( \"a,b\" ) def test_foo ( a , b ): # check that foo runs correctly and that the result is a tuple. assert isinstance ( foo ( a , b ), tuple ) As simple as that ! The syntax is basically the same than in pytest.mark.parametrize . Executing pytest will now run our test function once for every case function : >>> pytest -s -v ============================= test session starts ============================= ( ... ) <your_project>/tests/test_foo.py::test_foo [ two_positive_ints ] PASSED [ 50 % ] <your_project>/tests/test_foo.py::test_foo [ two_negative_ints ] PASSED [ 100 % ] ========================== 2 passed in 0 .24 seconds ========================== Tools for daily use \u00b6 a- Cases collection \u00b6 Alternate source(s) \u00b6 It is not mandatory that case functions should be in a different file than the test functions: both can be in the same file. For this you can use cases='.' or cases=THIS_MODULE to refer to the module in which the test function is located: from pytest_cases import parametrize_with_cases def case_one_positive_int (): return 1 def case_one_negative_int (): return - 1 @parametrize_with_cases ( \"i\" , cases = '.' ) def test_with_this_module ( i ): assert i == int ( i ) However WARNING : only the case functions defined BEFORE the test function in the module file will be taken into account! @parametrize_with_cases(cases=...) also accepts explicit list of case functions, classes containing case functions, and modules. See API Reference for details. A typical way to organize cases is to use classes for example: from pytest_cases import parametrize_with_cases class Foo : def case_a_positive_int ( self ): return 1 def case_another_positive_int ( self ): return 2 @parametrize_with_cases ( \"a\" , cases = Foo ) def test_foo ( a ): assert a > 0 Note that as for pytest , self is recreated for every test and therefore should not be used to store any useful information. Alternate prefix \u00b6 case_ might not be your preferred prefix, especially if you wish to store in the same module or class various kind of case data. @parametrize_with_cases offers a prefix=... argument to select an alternate prefix for your case functions. That way, you can store in the same module or class case functions as diverse as datasets (e.g. data_ ), user descriptions (e.g. user_ ), algorithms or machine learning models (e.g. model_ or algo_ ), etc. from pytest_cases import parametrize_with_cases , parametrize def data_a (): return 'a' @parametrize ( \"hello\" , [ True , False ]) def data_b ( hello ): return \"hello\" if hello else \"world\" def case_c (): return dict ( name = \"hi i'm not used\" ) def user_bob (): return \"bob\" @parametrize_with_cases ( \"data\" , cases = '.' , prefix = \"data_\" ) @parametrize_with_cases ( \"user\" , cases = '.' , prefix = \"user_\" ) def test_with_data ( data , user ): assert data in ( 'a' , \"hello\" , \"world\" ) assert user == 'bob' yields test_doc_filters_n_tags.py::test_with_data[bob-a] PASSED [ 33%] test_doc_filters_n_tags.py::test_with_data[bob-b-True] PASSED [ 66%] test_doc_filters_n_tags.py::test_with_data[bob-b-False] PASSED [ 100%] Filters and tags \u00b6 The easiest way to select only a subset of case functions in a module or a class, is to specify a custom prefix instead of the default one ( 'case_' ), as shown above . However sometimes more advanced filtering is required. In that case, you can also rely on three additional mechanisms provided in @parametrize_with_cases : the glob argument can contain a glob-like pattern for case ids. This can become handy to separate for example good or bad cases, the latter returning an expected error type and/or message for use with pytest.raises or with our alternative assert_exception . from math import sqrt import pytest from pytest_cases import parametrize_with_cases def case_int_success (): return 1 def case_negative_int_failure (): # note that we decide to return the expected type of failure to check it return - 1 , ValueError , \"math domain error\" @parametrize_with_cases ( \"data\" , cases = '.' , glob = \"*success\" ) def test_good_datasets ( data ): assert sqrt ( data ) > 0 @parametrize_with_cases ( \"data, err_type, err_msg\" , cases = '.' , glob = \"*failure\" ) def test_bad_datasets ( data , err_type , err_msg ): with pytest . raises ( err_type , match = err_msg ): sqrt ( data ) the has_tag argument allows you to filter cases based on tags set on case functions using the @case decorator. See API reference of @case and @parametrize_with_cases . from pytest_cases import parametrize_with_cases , case class FooCases : def case_two_positive_ints ( self ): return 1 , 2 @case ( tags = 'foo' ) def case_one_positive_int ( self ): return 1 @parametrize_with_cases ( \"a\" , cases = FooCases , has_tag = 'foo' ) def test_foo ( a ): assert a > 0 Finally if none of the above matches your expectations, you can provide a callable to filter . This callable will receive each collected case function and should return True (or a truth-value convertible object) in case of success. Note that your function can leverage the _pytestcase attribute available on the case function to read the tags, marks and id found on it. @parametrize_with_cases ( \"data\" , cases = '.' , filter = lambda cf : \"success\" in cf . _pytestcase . id ) def test_good_datasets2 ( data ): assert sqrt ( data ) > 0 b- Case functions \u00b6 Custom case name \u00b6 The id used by pytest for a given case is automatically taken from the case function name by removing the case_ (or other custom) prefix. It can instead be customized explicitly by decorating your case function with the @case(id=<id>) decorator. See API reference . from pytest_cases import case @case ( id = \"2 positive integers\" ) def case_two_positive_ints (): return 1 , 2 Pytest marks ( skip , xfail ...) \u00b6 pytest marks such as @pytest.mark.skipif can be applied on case functions the same way as with test functions . import sys import pytest @pytest . mark . skipif ( sys . version_info < ( 3 , 0 ), reason = \"Not useful on python 2\" ) def case_two_positive_ints (): return 1 , 2 Case generators \u00b6 In many real-world usage we want to generate one test case per <something> . The most intuitive way would be to use a for loop to create the case functions, and to use the @case decorator to set their names ; however this would not be very readable. Instead, case functions can be parametrized the same way as with test functions : simply add the parameter names as arguments in their signature and decorate with @pytest.mark.parametrize . Even better, you can use the enhanced @parametrize from pytest-cases so as to benefit from its additional usability features (see API reference ): from pytest_cases import parametrize , parametrize_with_cases class CasesFoo : def case_hello ( self ): return \"hello world\" @parametrize ( who = ( 'you' , 'there' )) def case_simple_generator ( self , who ): return \"hello %s \" % who @parametrize_with_cases ( \"msg\" , cases = CasesFoo ) def test_foo ( msg ): assert isinstance ( msg , str ) and msg . startswith ( \"hello\" ) Yields test_generators.py::test_foo[hello] PASSED [ 33%] test_generators.py::test_foo[simple_generator-who=you] PASSED [ 66%] test_generators.py::test_foo[simple_generator-who=there] PASSED [100%] Cases requiring fixtures \u00b6 Cases can use fixtures the same way as test functions do : simply add the fixture names as arguments in their signature and make sure the fixture exists either in the same module, or in a conftest.py file in one of the parent packages. See pytest documentation on sharing fixtures . from pytest_cases import parametrize_with_cases , fixture , parametrize @fixture ( scope = 'session' ) def db (): return { 0 : 'louise' , 1 : 'bob' } def user_bob ( db ): return db [ 1 ] @parametrize ( id = range ( 2 )) def user_from_db ( db , id ): return db [ id ] @parametrize_with_cases ( \"a\" , cases = '.' , prefix = 'user_' ) def test_users ( a , db , request ): print ( \"this is test %r \" % request . node . nodeid ) assert a in db . values () yields test_fixtures.py::test_users[a_is_bob] test_fixtures.py::test_users[a_is_from_db-id=0] test_fixtures.py::test_users[a_is_from_db-id=1] Advanced topics \u00b6 a- Test fixtures \u00b6 In some scenarii you might wish to parametrize a fixture with the cases, rather than the test function. For example to inject the same test cases in several test functions without duplicating the @parametrize_with_cases decorator on each of them, to generate the test cases once for the whole session, using a scope='session' fixture or another scope , to modify the test cases, log some message, or perform some other action before injecting them into the test functions, and/or after executing the test function (thanks to yield fixtures ) ... For this, simply use @fixture from pytest_cases instead of @pytest.fixture to define your fixture. That allows your fixtures to be easily parametrized with @parametrize_with_cases , @parametrize , and even @pytest.mark.parametrize . from pytest_cases import fixture , parametrize_with_cases @fixture @parametrize_with_cases ( \"a,b\" ) def c ( a , b ): return a + b def test_foo ( c ): assert isinstance ( c , int ) b- Caching cases \u00b6 After starting to reuse cases in several test functions, you might end-up thinking \"why do I have to spend the data parsing/generation time several times ? It is the same case.\" . There are several ways to solve this issue: the easiest way is to use fixtures with a broad scope , as explained above . However in some parametrization scenarii, pytest does not guarantee that the fixture will be setup only once for the whole session, even if it is a session-scoped fixture. Also the cases will be parsed everytime you run pytest, which might be cumbersome from pytest_cases import parametrize , parametrize_with_cases , fixture @parametrize ( a = range ( 2 )) def case_dummy ( a ): # this is read only once per a, while there are 4 test runs return a @fixture ( scope = 'session' ) @parametrize_with_cases ( \"a\" , cases = '.' ) def cached_a ( a ): return a @parametrize ( d = range ( 2 )) def test_caching ( cached_a , d ): assert d < 2 assert 0 <= cached_a <= 1 an alternative is to use functools.lru_cache to explicitly set a memory cache on a case function. For simple cases you could simply decorate your case function with @lru_cache(maxsize=1) since simple case functions do not have arguments. However for case generators this is a bit more tricky to size the cache - the easiest thing is probably to let it to its default size of 128 with the no-argument version @lru_cache , or to remove the max limit and let it auto-grow, with @lru_cache(max_size=None) . See lru_cache documentation for details . Note that an older version of pytest-cases was offering some facilities to set the cache size, this has been removed from the library in version 2.0.0 as it seemed to provide little added value. finally, you might wish to persist some cases on disk in order for example to avoid downloading them again from their original source, and/or to avoid costly processing on every pytest session. For this, the perfect match for you is to use joblib 's excellent Memory cache . Main features / benefits \u00b6 Separation of concerns : test code on one hand, test cases data on the other hand. This is particularly relevant for data science projects where a lot of test datasets are used on the same block of test code. Everything in the test case or in the fixture , not outside. A side-effect of @pytest.mark.parametrize is that users tend to create or parse their datasets outside of the test function. pytest_cases suggests a model where the potentially time and memory consuming step of case data generation/retrieval is performed inside the test node or the required fixture, thus keeping every test case run more independent. It is also easy to put debug breakpoints on specific test cases. User experience fully aligned with pytest . Cases collection and filtering, cases parametrization, cases output unpacking as test arguments, cases using fixtures... all of this will look very familiar to pytest users. See Also \u00b6 pytest documentation on parametrize pytest documentation on fixtures pytest-steps pytest-harvest pytest-patterns for examples showing how to combine the various plugins to create data science benchmarks. Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-pytest-cases","title":"Home"},{"location":"#pytest-cases","text":"Separate test code from test cases in pytest . Brand new v2, check the changes ! Installing pytest-cases has effects on the order of pytest tests execution. Details here Did you ever think that most of your test functions were actually the same test code , but with different data inputs and expected results/exceptions ? pytest-cases leverages pytest and its great @pytest.mark.parametrize decorator, so that you can separate your test cases from your test functions . In addition, pytest-cases improves pytest 's fixture mechanism to support \"fixture unions\". This is a major change in the internal pytest engine, unlocking many possibilities such as using fixture references as parameter values in a test function. See here . pytest-cases is fully compliant with pytest-harvest so you can easily monitor the execution times and created artifacts. With it, it becomes very easy to create a complete data science benchmark, for example comparing various models on various datasets as illustrated below (from the example section):","title":"pytest-cases"},{"location":"#installing","text":"> pip install pytest_cases Note: Installing pytest-cases has effects on the order of pytest tests execution, even if you do not use its features. One positive side effect is that it fixed pytest#5054 . But if you see less desirable ordering please report it .","title":"Installing"},{"location":"#why-pytest-cases","text":"pytest philosophy Let's consider the following foo function under test, located in example.py : def foo ( a , b ): return a + 1 , b + 1 If we were using plain pytest to test it with various inputs, we would create a test_foo.py file and use @pytest.mark.parametrize : import pytest from example import foo @pytest . mark . parametrize ( \"a,b\" , [( 1 , 2 ), ( - 1 , - 2 )]) def test_foo ( a , b ): # check that foo runs correctly and that the result is a tuple. assert isinstance ( foo ( a , b ), tuple ) This is the fastest and most compact thing to do when you have a few number of test cases, that do not require code to generate each test case. pytest current limitations Now imagine that instead of (1, 2) and (-1, -2) each of our test cases requires a few lines of code to be generated. For example artificial data creation using numpy and/or pandas : import numpy as np import pandas as pd # case 1: non-sorted uniformly sampled timeseries with 2 holes case1 = pd . DataFrame ({ \"datetime\" : pd . date_range ( start = '20/1/1' , periods = 20 , freq = '-1d' , tz = 'UTC' ), \"data1\" : np . arange ( 0 , 20 ), \"data2\" : np . arange ( 1 , 21 ), \"data3\" : np . arange ( 1 , 21 )}) case1 . drop ([ 3 , 12 ], inplace = True ) requires documentation to explain the other developers the intent of that precise test case requires external resources (data files on the filesystem, databases...), with a variable number of cases depending on what is available on the resource - but of course not all the cases would come from the same resource, that would be too easy :). requires a readable id , such as 'uniformly_sampled_nonsorted_with_holes' for the above example. Of course we could use pytest.param or ids=<list> but that is \"a pain to maintain\" according to pytest doc (I agree!). Such a design does not feel right as the id is detached from the case. With standard pytest there is no particular pattern to simplify your life here. Investigating a little bit, people usually end up trying to mix parameters and fixtures and asking this kind of question: so1 , so2 . But by design it is not possible to solve this problem using fixtures, because pytest does not handle \"unions\" of fixtures . So all in all, the final answer is \"you have to do this yourself\", and have pytest use your handcrafted list of parameters as the list of argvalues in @pytest.mark.parametrize . Typically we would end up creating a get_all_foo_test_cases function, independently from pytest : @pytest . mark . parametrize ( \"a,b\" , get_all_foo_test_cases ()) def test_foo ( a , b ): ... There is also an example in pytest doc with a metafunc hook . The issue with such workarounds is that you can do anything . And anything is a bit too much: this does not provide any convention / \"good practice\" on how to organize test cases, which is an open door to developing ad-hoc unreadable or unmaintainable solutions. pytest_cases was created to provide an answer to this precise situation. It proposes a simple framework to separate test cases from test functions. The test cases are typically located in a separate \"companion\" file: test_foo.py is your usual test file containing the test functions (named test_<id> ), test_foo_cases.py contains the test cases , that are also functions (named case_<id> or even <prefix>_<id> if you prefer). Note: an alternate file naming style cases_foo.py is also available if you prefer it. Test cases can also be provided explicitly, for example in a class container: And many more as we'll see below .","title":"Why pytest-cases ?"},{"location":"#basic-usage","text":"","title":"Basic usage"},{"location":"#a-case-functions","text":"Let's create a test_foo_cases.py file. This file will contain test cases generator functions , that we will call case functions for brevity. In these functions, you will typically either parse some test data files, generate some simulated test data, expected results, etc. def case_two_positive_ints (): \"\"\" Inputs are two positive integers \"\"\" return 1 , 2 def case_two_negative_ints (): \"\"\" Inputs are two negative integers \"\"\" return - 1 , - 2 Case functions do not have any particular requirement , apart from the default name convention case_<id> - but even that can be customized: you can use distinct prefixes to denote distinct kind of parameters, such as data_<id> , user_<id> , model_<id> ... Case functions can return anything that is considered useful to run the associated test. We will see below that you can use all classic pytest mechanism on case functions (id customization, skip/fail marks, parametrization, fixtures injection).","title":"a- Case functions"},{"location":"#b-test-functions","text":"As usual we write our pytest test functions starting with test_ , in a test_foo.py file. The only difference is that we now decorate it with @parametrize_with_cases instead of @pytest.mark.parametrize as we were doing previously : from example import foo from pytest_cases import parametrize_with_cases @parametrize_with_cases ( \"a,b\" ) def test_foo ( a , b ): # check that foo runs correctly and that the result is a tuple. assert isinstance ( foo ( a , b ), tuple ) As simple as that ! The syntax is basically the same than in pytest.mark.parametrize . Executing pytest will now run our test function once for every case function : >>> pytest -s -v ============================= test session starts ============================= ( ... ) <your_project>/tests/test_foo.py::test_foo [ two_positive_ints ] PASSED [ 50 % ] <your_project>/tests/test_foo.py::test_foo [ two_negative_ints ] PASSED [ 100 % ] ========================== 2 passed in 0 .24 seconds ==========================","title":"b- Test functions"},{"location":"#tools-for-daily-use","text":"","title":"Tools for daily use"},{"location":"#a-cases-collection","text":"","title":"a- Cases collection"},{"location":"#alternate-sources","text":"It is not mandatory that case functions should be in a different file than the test functions: both can be in the same file. For this you can use cases='.' or cases=THIS_MODULE to refer to the module in which the test function is located: from pytest_cases import parametrize_with_cases def case_one_positive_int (): return 1 def case_one_negative_int (): return - 1 @parametrize_with_cases ( \"i\" , cases = '.' ) def test_with_this_module ( i ): assert i == int ( i ) However WARNING : only the case functions defined BEFORE the test function in the module file will be taken into account! @parametrize_with_cases(cases=...) also accepts explicit list of case functions, classes containing case functions, and modules. See API Reference for details. A typical way to organize cases is to use classes for example: from pytest_cases import parametrize_with_cases class Foo : def case_a_positive_int ( self ): return 1 def case_another_positive_int ( self ): return 2 @parametrize_with_cases ( \"a\" , cases = Foo ) def test_foo ( a ): assert a > 0 Note that as for pytest , self is recreated for every test and therefore should not be used to store any useful information.","title":"Alternate source(s)"},{"location":"#alternate-prefix","text":"case_ might not be your preferred prefix, especially if you wish to store in the same module or class various kind of case data. @parametrize_with_cases offers a prefix=... argument to select an alternate prefix for your case functions. That way, you can store in the same module or class case functions as diverse as datasets (e.g. data_ ), user descriptions (e.g. user_ ), algorithms or machine learning models (e.g. model_ or algo_ ), etc. from pytest_cases import parametrize_with_cases , parametrize def data_a (): return 'a' @parametrize ( \"hello\" , [ True , False ]) def data_b ( hello ): return \"hello\" if hello else \"world\" def case_c (): return dict ( name = \"hi i'm not used\" ) def user_bob (): return \"bob\" @parametrize_with_cases ( \"data\" , cases = '.' , prefix = \"data_\" ) @parametrize_with_cases ( \"user\" , cases = '.' , prefix = \"user_\" ) def test_with_data ( data , user ): assert data in ( 'a' , \"hello\" , \"world\" ) assert user == 'bob' yields test_doc_filters_n_tags.py::test_with_data[bob-a] PASSED [ 33%] test_doc_filters_n_tags.py::test_with_data[bob-b-True] PASSED [ 66%] test_doc_filters_n_tags.py::test_with_data[bob-b-False] PASSED [ 100%]","title":"Alternate prefix"},{"location":"#filters-and-tags","text":"The easiest way to select only a subset of case functions in a module or a class, is to specify a custom prefix instead of the default one ( 'case_' ), as shown above . However sometimes more advanced filtering is required. In that case, you can also rely on three additional mechanisms provided in @parametrize_with_cases : the glob argument can contain a glob-like pattern for case ids. This can become handy to separate for example good or bad cases, the latter returning an expected error type and/or message for use with pytest.raises or with our alternative assert_exception . from math import sqrt import pytest from pytest_cases import parametrize_with_cases def case_int_success (): return 1 def case_negative_int_failure (): # note that we decide to return the expected type of failure to check it return - 1 , ValueError , \"math domain error\" @parametrize_with_cases ( \"data\" , cases = '.' , glob = \"*success\" ) def test_good_datasets ( data ): assert sqrt ( data ) > 0 @parametrize_with_cases ( \"data, err_type, err_msg\" , cases = '.' , glob = \"*failure\" ) def test_bad_datasets ( data , err_type , err_msg ): with pytest . raises ( err_type , match = err_msg ): sqrt ( data ) the has_tag argument allows you to filter cases based on tags set on case functions using the @case decorator. See API reference of @case and @parametrize_with_cases . from pytest_cases import parametrize_with_cases , case class FooCases : def case_two_positive_ints ( self ): return 1 , 2 @case ( tags = 'foo' ) def case_one_positive_int ( self ): return 1 @parametrize_with_cases ( \"a\" , cases = FooCases , has_tag = 'foo' ) def test_foo ( a ): assert a > 0 Finally if none of the above matches your expectations, you can provide a callable to filter . This callable will receive each collected case function and should return True (or a truth-value convertible object) in case of success. Note that your function can leverage the _pytestcase attribute available on the case function to read the tags, marks and id found on it. @parametrize_with_cases ( \"data\" , cases = '.' , filter = lambda cf : \"success\" in cf . _pytestcase . id ) def test_good_datasets2 ( data ): assert sqrt ( data ) > 0","title":"Filters and tags"},{"location":"#b-case-functions","text":"","title":"b- Case functions"},{"location":"#custom-case-name","text":"The id used by pytest for a given case is automatically taken from the case function name by removing the case_ (or other custom) prefix. It can instead be customized explicitly by decorating your case function with the @case(id=<id>) decorator. See API reference . from pytest_cases import case @case ( id = \"2 positive integers\" ) def case_two_positive_ints (): return 1 , 2","title":"Custom case name"},{"location":"#pytest-marks-skip-xfail","text":"pytest marks such as @pytest.mark.skipif can be applied on case functions the same way as with test functions . import sys import pytest @pytest . mark . skipif ( sys . version_info < ( 3 , 0 ), reason = \"Not useful on python 2\" ) def case_two_positive_ints (): return 1 , 2","title":"Pytest marks (skip, xfail...)"},{"location":"#case-generators","text":"In many real-world usage we want to generate one test case per <something> . The most intuitive way would be to use a for loop to create the case functions, and to use the @case decorator to set their names ; however this would not be very readable. Instead, case functions can be parametrized the same way as with test functions : simply add the parameter names as arguments in their signature and decorate with @pytest.mark.parametrize . Even better, you can use the enhanced @parametrize from pytest-cases so as to benefit from its additional usability features (see API reference ): from pytest_cases import parametrize , parametrize_with_cases class CasesFoo : def case_hello ( self ): return \"hello world\" @parametrize ( who = ( 'you' , 'there' )) def case_simple_generator ( self , who ): return \"hello %s \" % who @parametrize_with_cases ( \"msg\" , cases = CasesFoo ) def test_foo ( msg ): assert isinstance ( msg , str ) and msg . startswith ( \"hello\" ) Yields test_generators.py::test_foo[hello] PASSED [ 33%] test_generators.py::test_foo[simple_generator-who=you] PASSED [ 66%] test_generators.py::test_foo[simple_generator-who=there] PASSED [100%]","title":"Case generators"},{"location":"#cases-requiring-fixtures","text":"Cases can use fixtures the same way as test functions do : simply add the fixture names as arguments in their signature and make sure the fixture exists either in the same module, or in a conftest.py file in one of the parent packages. See pytest documentation on sharing fixtures . from pytest_cases import parametrize_with_cases , fixture , parametrize @fixture ( scope = 'session' ) def db (): return { 0 : 'louise' , 1 : 'bob' } def user_bob ( db ): return db [ 1 ] @parametrize ( id = range ( 2 )) def user_from_db ( db , id ): return db [ id ] @parametrize_with_cases ( \"a\" , cases = '.' , prefix = 'user_' ) def test_users ( a , db , request ): print ( \"this is test %r \" % request . node . nodeid ) assert a in db . values () yields test_fixtures.py::test_users[a_is_bob] test_fixtures.py::test_users[a_is_from_db-id=0] test_fixtures.py::test_users[a_is_from_db-id=1]","title":"Cases requiring fixtures"},{"location":"#advanced-topics","text":"","title":"Advanced topics"},{"location":"#a-test-fixtures","text":"In some scenarii you might wish to parametrize a fixture with the cases, rather than the test function. For example to inject the same test cases in several test functions without duplicating the @parametrize_with_cases decorator on each of them, to generate the test cases once for the whole session, using a scope='session' fixture or another scope , to modify the test cases, log some message, or perform some other action before injecting them into the test functions, and/or after executing the test function (thanks to yield fixtures ) ... For this, simply use @fixture from pytest_cases instead of @pytest.fixture to define your fixture. That allows your fixtures to be easily parametrized with @parametrize_with_cases , @parametrize , and even @pytest.mark.parametrize . from pytest_cases import fixture , parametrize_with_cases @fixture @parametrize_with_cases ( \"a,b\" ) def c ( a , b ): return a + b def test_foo ( c ): assert isinstance ( c , int )","title":"a- Test fixtures"},{"location":"#b-caching-cases","text":"After starting to reuse cases in several test functions, you might end-up thinking \"why do I have to spend the data parsing/generation time several times ? It is the same case.\" . There are several ways to solve this issue: the easiest way is to use fixtures with a broad scope , as explained above . However in some parametrization scenarii, pytest does not guarantee that the fixture will be setup only once for the whole session, even if it is a session-scoped fixture. Also the cases will be parsed everytime you run pytest, which might be cumbersome from pytest_cases import parametrize , parametrize_with_cases , fixture @parametrize ( a = range ( 2 )) def case_dummy ( a ): # this is read only once per a, while there are 4 test runs return a @fixture ( scope = 'session' ) @parametrize_with_cases ( \"a\" , cases = '.' ) def cached_a ( a ): return a @parametrize ( d = range ( 2 )) def test_caching ( cached_a , d ): assert d < 2 assert 0 <= cached_a <= 1 an alternative is to use functools.lru_cache to explicitly set a memory cache on a case function. For simple cases you could simply decorate your case function with @lru_cache(maxsize=1) since simple case functions do not have arguments. However for case generators this is a bit more tricky to size the cache - the easiest thing is probably to let it to its default size of 128 with the no-argument version @lru_cache , or to remove the max limit and let it auto-grow, with @lru_cache(max_size=None) . See lru_cache documentation for details . Note that an older version of pytest-cases was offering some facilities to set the cache size, this has been removed from the library in version 2.0.0 as it seemed to provide little added value. finally, you might wish to persist some cases on disk in order for example to avoid downloading them again from their original source, and/or to avoid costly processing on every pytest session. For this, the perfect match for you is to use joblib 's excellent Memory cache .","title":"b- Caching cases"},{"location":"#main-features-benefits","text":"Separation of concerns : test code on one hand, test cases data on the other hand. This is particularly relevant for data science projects where a lot of test datasets are used on the same block of test code. Everything in the test case or in the fixture , not outside. A side-effect of @pytest.mark.parametrize is that users tend to create or parse their datasets outside of the test function. pytest_cases suggests a model where the potentially time and memory consuming step of case data generation/retrieval is performed inside the test node or the required fixture, thus keeping every test case run more independent. It is also easy to put debug breakpoints on specific test cases. User experience fully aligned with pytest . Cases collection and filtering, cases parametrization, cases output unpacking as test arguments, cases using fixtures... all of this will look very familiar to pytest users.","title":"Main features / benefits"},{"location":"#see-also","text":"pytest documentation on parametrize pytest documentation on fixtures pytest-steps pytest-harvest pytest-patterns for examples showing how to combine the various plugins to create data science benchmarks.","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-pytest-cases","title":"Want to contribute ?"},{"location":"api_reference/","text":"API reference \u00b6 In general, using help(symbol) is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package. 1 - Case functions \u00b6 As explained in the documentation , case functions have no requirement anymore, and starting from version 2.0.0 of pytest_cases they can be parametrized with the usual @pytest.mark.parametrize or its improvement @parametrize . Therefore the only remaining decorator is the optional @case decorator: @case \u00b6 @case ( id = None , # type: str # noqa tags = None , # type: Union[Any, Iterable[Any]] marks = (), # type: Union[MarkDecorator, Iterable[MarkDecorator]] ) Optional decorator for case functions so as to customize some information. @case ( id = 'hey' ) def case_hi (): return 1 Parameters: id : the custom pytest id that should be used when this case is active. Replaces the deprecated @case_name decorator from v1. If no id is provided, the id is generated from case functions by removing their prefix, see @parametrize_with_cases(prefix='case_') . tags : custom tags to be used for filtering in @parametrize_with_cases(has_tags) . Replaces the deprecated @case_tags and @target decorators. marks : optional pytest marks to add on the case. Note that decorating the function directly with the mark also works, and if marks are provided in both places they are merged. 2 - Cases collection \u00b6 @parametrize_with_cases \u00b6 @parametrize_with_cases ( argnames : str , cases : Union [ Callable , Type , ModuleRef ] = AUTO , prefix : str = 'case_' , glob : str = None , has_tag : Union [ str , Iterable [ str ]] = None , filter : Callable = None , ** kwargs ) A decorator for test functions or fixtures, to parametrize them based on test cases. It works similarly to @pytest.mark.parametrize : argnames represent a coma-separated string of arguments to inject in the decorated test function or fixture. The argument values ( argvalues in @pytest.mark.parametrize ) are collected from the various case functions found according to cases , and injected as lazy values so that the case functions are called just before the test or fixture is executed. By default ( cases=AUTO ) the list of test cases is automatically drawn from the python module file named test_<name>_cases.py where test_<name> is the current module name. An alternate naming convention cases_<name>.py can be used by setting cases=AUTO2 . Finally, the cases argument also accepts an explicit case function, cases-containing class, module or module name; or a list of such elements. Note that both absolute and relative module names are suported. Note that @parametrize_with_cases collection and parameter creation steps are strictly equivalent to get_all_cases + get_parametrize_args . This can be handy for debugging purposes. # Collect all cases cases_funs = get_all_cases ( f , cases = cases , prefix = prefix , glob = glob , has_tag = has_tag , filter = filter ) # Transform the various functions found argvalues = get_parametrize_args ( cases_funs ) Parameters argnames : same than in @pytest.mark.parametrize cases : a case function, a class containing cases, a module object or a module name string (relative module names accepted). Or a list of such items. You may use THIS_MODULE or '.' to include current module. AUTO (default) means that the module named test_<name>_cases.py will be loaded, where test_<name>.py is the module file of the decorated function. AUTO2 allows you to use the alternative naming scheme case_<name>.py . When a module is listed, all of its functions matching the prefix , filter and has_tag are selected, including those functions nested in classes following naming pattern *Case* . When classes are explicitly provided in the list, they can have any name and do not need to follow this *Case* pattern. prefix : the prefix for case functions. Default is 'case_' but you might wish to use different prefixes to denote different kind of cases, for example 'data_', 'algo_', 'user_', etc. glob : an optional glob-like pattern for case ids, for example \" _success\" or \" _failure\". Note that this is applied on the case id, and therefore if it is customized through @case(id=...) it should be taken into account. has_tag : a single tag or a tuple, set, list of tags that should be matched by the ones set with the @case decorator on the case function(s) to be selected. filter : a callable receiving the case function and returning True or a truth value in case the function needs to be selected. get_all_cases \u00b6 def get_all_cases ( parametrization_target : Callable , cases : Union [ Callable , Type , ModuleRef ] = None , prefix : str = 'case_' , glob : str = None , has_tag : Union [ str , Iterable [ str ]] = None , filter : Callable [[ Callable ], bool ] = None ) -> List [ Callable ]: Lists all desired cases for a given parametrization_target (a test function or a fixture). This function may be convenient for debugging purposes. See @parametrize_with_cases for details on the parameters. get_parametrize_args \u00b6 def get_parametrize_args ( cases_funs : List [ Callable ], ) -> List [ Union [ lazy_value , fixture_ref ]]: Transforms a list of cases (obtained from get_all_cases ) into a list of argvalues for @parametrize . Each case function case_fun is transformed into one or several lazy_value (s) or a fixture_ref : If case_fun requires at least on fixture, a fixture will be created if not yet present, and a fixture_ref will be returned. If case_fun is a parametrized case, one lazy_value with a partialized version will be created for each parameter combination. Otherwise, case_fun represents a single case: in that case a single lazy_value is returned. 3 - Pytest goodies \u00b6 @fixture \u00b6 @fixture ( scope : str = \"function\" , autouse : bool = False , name : str = None , unpack_into : Iterable [ str ] = None , hook : Callable = None , ** kwargs ) Identical to @pytest.fixture decorator, except that it supports multi-parametrization with @pytest.mark.parametrize as requested in pytest#3960 . As a consequence it does not support the params and ids arguments anymore. it supports a new argument unpack_into where you can provide names for fixtures where to unpack this fixture into. As a consequence it does not support the params and ids arguments anymore. Parameters: scope : the scope for which this fixture is shared, one of \"function\" (default), \"class\", \"module\" or \"session\". autouse : if True, the fixture func is activated for all tests that can see it. If False (the default) then an explicitreference is needed to activate the fixture. name : the name of the fixture. This defaults to the name of the decorated function. Note: If a fixture is used in the same module in which it is defined, the function name of the fixture will be shadowed by the function arg that requests the fixture; one wayto resolve this is to name the decorated function fixture_<fixturename> and then use @pytest.fixture(name='<fixturename>') . unpack_into : an optional iterable of names, or string containing coma-separated names, for additional fixtures to create to represent parts of this fixture. See unpack_fixture for details. hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. kwargs : other keyword arguments for @pytest.fixture unpack_fixture \u00b6 def unpack_fixture ( argnames : str , fixture : Union [ str , Callable ], hook : Callable = None ) -> Tuple [ < Fixture > ] Creates several fixtures with names argnames from the source fixture . Created fixtures will correspond to elements unpacked from fixture in order. For example if fixture is a tuple of length 2, argnames=\"a,b\" will create two fixtures containing the first and second element respectively. The created fixtures are automatically registered into the callers' module, but you may wish to assign them to variables for convenience. In that case make sure that you use the same names, e.g. a, b = unpack_fixture('a,b', 'c') . import pytest from pytest_cases import unpack_fixture , fixture_plus @fixture_plus @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] a , b = unpack_fixture ( \"a,b\" , c ) def test_function ( a , b ): assert a [ 0 ] == b Parameters argnames : same as @pytest.mark.parametrize argnames . fixture : a fixture name string or a fixture symbol. If a fixture symbol is provided, the created fixtures will have the same scope. If a name is provided, they will have scope='function'. Note that in practice the performance loss resulting from using function rather than a higher scope is negligible since the created fixtures' body is a one-liner. hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. Outputs: the created fixtures. fixture_union \u00b6 def fixture_union ( name : str , fixtures : Iterable [ Union [ str , Callable ]], scope : str = \"function\" , idstyle : Optional [ str ] = 'explicit' , ids : Union [ Callable , List [ str ]] = None , unpack_into : Iterable [ str ] = None , autouse : bool = False , hook : Callable = None , ** kwargs ) -> < Fixture > Creates a fixture that will take all values of the provided fixtures in order. That fixture is automatically registered into the callers' module, but you may wish to assign it to a variable for convenience. In that case make sure that you use the same name, e.g. a = fixture_union('a', ['b', 'c']) The style of test ids corresponding to the union alternatives can be changed with idstyle . Three values are allowed: 'explicit' (default) favors readability, 'compact' adds a small mark so that at least one sees which parameters are union parameters and which others are normal parameters, None does not change the ids. Parameters: name : the name of the fixture to create fixtures : an array-like containing fixture names and/or fixture symbols scope : the scope of the union. Since the union depends on the sub-fixtures, it should be smaller than the smallest scope of fixtures referenced. idstyle : The style of test ids corresponding to the union alternatives. One of 'explicit' (default), 'compact' , or None . unpack_into : an optional iterable of names, or string containing coma-separated names, for additional fixtures to create to represent parts of this fixture. See unpack_fixture for details. ids : as in pytest. The default value returns the correct fixture autouse : as in pytest hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. kwargs : other pytest fixture options. They might not be supported correctly. Outputs: the new fixture. Note: you do not need to capture that output in a symbol, since the fixture is automatically registered in your module. However if you decide to do so make sure that you use the same name. param_fixtures \u00b6 def param_fixtures ( argnames : str , argvalues : Iterable [ Any ], autouse : bool = False , ids : Union [ Callable , List [ str ]] = None , scope : str = \"function\" , hook : Callable = None , debug : bool = False , ** kwargs ) -> Tuple [ < Fixture > ] Creates one or several \"parameters\" fixtures - depending on the number or coma-separated names in argnames . The created fixtures are automatically registered into the callers' module, but you may wish to assign them to variables for convenience. In that case make sure that you use the same names, e.g. p, q = param_fixtures('p,q', [(0, 1), (2, 3)]) . Note that the (argnames, argvalues, ids) signature is similar to @pytest.mark.parametrize for consistency, see pytest doc on parametrize . import pytest from pytest_cases import param_fixtures , param_fixture # create a 2-tuple parameter fixture arg1 , arg2 = param_fixtures ( \"arg1, arg2\" , [( 1 , 2 ), ( 3 , 4 )]) @pytest . fixture def fixture_uses_param2 ( arg2 ): ... def test_uses_param2 ( arg1 , arg2 , fixture_uses_param2 ): ... Parameters: argnames : same as @pytest.mark.parametrize argnames . argvalues : same as @pytest.mark.parametrize argvalues . autouse : see fixture autouse ids : same as @pytest.mark.parametrize ids scope : see fixture scope hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. kwargs : any other argument for the created 'fixtures' param_fixture \u00b6 param_fixture ( argname , argvalues , autouse = False , ids = None , hook = None , scope = \"function\" , ** kwargs ) -> < Fixture > Identical to param_fixtures but for a single parameter name, so that you can assign its output to a single variable. @parametrize \u00b6 @parametrize_plus ( argnames : str = None , argvalues : Iterable [ Any ] = None , indirect : bool = False , ids : Union [ Callable , List [ str ]] = None , idstyle : str = 'explicit' , idgen : Union [ str , Callable ] = _IDGEN , scope : str = None , hook : Callable = None , debug : bool = False , ** args ) Equivalent to @pytest.mark.parametrize but also supports New alternate style for argnames/argvalues . One can also use **args to pass additional {argnames: argvalues} in the same parametrization call. This can be handy in combination with idgen to master the whole id template associated with several parameters. Note that you can pass coma-separated argnames too, by de-referencing a dict: e.g. **{'a,b': [(0, True), (1, False)], 'c': [-1, 2]} . New alternate style for ids . One can use idgen instead of ids . idgen can be a callable receiving all parameters at once ( **args ) and returning an id ; or it can be a string template using the new-style string formatting where the argnames can be used as variables (e.g. idgen=lambda **args: \"a={a}\".format(**args) or idgen=\"my_id where a={a}\" ). The special idgen=AUTO symbol can be used to generate a default string template equivalent to lambda **args: \"-\".join(\"%s=%s\" % (n, v) for n, v in args.items()) . This is enabled by default if you use the alternate style for argnames/argvalues (e.g. if len(args) > 0 ). New possibilities in argvalues : one can include references to fixtures with fixture_ref(<fixture>) where can be the fixture name or fixture function. When such a fixture reference is detected in the argvalues, a new function-scope \"union\" fixture will be created with a unique name, and the test function will be wrapped so as to be injected with the correct parameters from this fixture. Special test ids will be created to illustrate the switching between the various normal parameters and fixtures. You can see debug print messages about all fixtures created using debug=True one can include lazy argvalues with lazy_value(<valuegetter>, [id=..., marks=...]) . A lazy_value is the same thing than a function-scoped fixture, except that the value getter function is not a fixture and therefore can neither be parametrized nor depend on fixtures. It should have no mandatory argument. Both fixture_ref and lazy_value can be used to represent a single argvalue, or a whole tuple of argvalues when there are several argnames. Several of them can be used in a tuple. Finally, pytest.param is supported even when there are fixture_ref and lazy_value . Here as for all functions above, an optional hook can be passed, to apply on each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. lazy_value \u00b6 def lazy_value ( valuegetter : Callable [[], Any ], id : str = None , marks : Union [ Any , Sequence [ Any ]] = () ) -> LazyValue A reference to a value getter (an argvalue-providing callable), to be used in @parametrize . A lazy_value is the same thing than a function-scoped fixture, except that the value getter function is not a fixture and therefore can neither be parametrized nor depend on fixtures. It should have no mandatory argument. Note that a lazy_value can be included in a pytest.param without problem. In that case the id defined by pytest.param will take precedence over the one defined in lazy_value if any. The marks, however, will all be kept wherever they are defined. Parameters valuegetter : a callable without mandatory arguments id : an optional id. Otherwise valuegetter.__name__ will be used by default marks : optional marks. valuegetter marks will also be preserved. fixture_ref \u00b6 def fixture_ref ( fixture : Union [ str , Fixture ] ) A reference to a fixture to be used with @parametrize . Create it with fixture_ref(<fixture>) where can be the fixture name or actual fixture function.","title":"API reference"},{"location":"api_reference/#api-reference","text":"In general, using help(symbol) is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package.","title":"API reference"},{"location":"api_reference/#1-case-functions","text":"As explained in the documentation , case functions have no requirement anymore, and starting from version 2.0.0 of pytest_cases they can be parametrized with the usual @pytest.mark.parametrize or its improvement @parametrize . Therefore the only remaining decorator is the optional @case decorator:","title":"1 - Case functions"},{"location":"api_reference/#case","text":"@case ( id = None , # type: str # noqa tags = None , # type: Union[Any, Iterable[Any]] marks = (), # type: Union[MarkDecorator, Iterable[MarkDecorator]] ) Optional decorator for case functions so as to customize some information. @case ( id = 'hey' ) def case_hi (): return 1 Parameters: id : the custom pytest id that should be used when this case is active. Replaces the deprecated @case_name decorator from v1. If no id is provided, the id is generated from case functions by removing their prefix, see @parametrize_with_cases(prefix='case_') . tags : custom tags to be used for filtering in @parametrize_with_cases(has_tags) . Replaces the deprecated @case_tags and @target decorators. marks : optional pytest marks to add on the case. Note that decorating the function directly with the mark also works, and if marks are provided in both places they are merged.","title":"@case"},{"location":"api_reference/#2-cases-collection","text":"","title":"2 - Cases collection"},{"location":"api_reference/#parametrize_with_cases","text":"@parametrize_with_cases ( argnames : str , cases : Union [ Callable , Type , ModuleRef ] = AUTO , prefix : str = 'case_' , glob : str = None , has_tag : Union [ str , Iterable [ str ]] = None , filter : Callable = None , ** kwargs ) A decorator for test functions or fixtures, to parametrize them based on test cases. It works similarly to @pytest.mark.parametrize : argnames represent a coma-separated string of arguments to inject in the decorated test function or fixture. The argument values ( argvalues in @pytest.mark.parametrize ) are collected from the various case functions found according to cases , and injected as lazy values so that the case functions are called just before the test or fixture is executed. By default ( cases=AUTO ) the list of test cases is automatically drawn from the python module file named test_<name>_cases.py where test_<name> is the current module name. An alternate naming convention cases_<name>.py can be used by setting cases=AUTO2 . Finally, the cases argument also accepts an explicit case function, cases-containing class, module or module name; or a list of such elements. Note that both absolute and relative module names are suported. Note that @parametrize_with_cases collection and parameter creation steps are strictly equivalent to get_all_cases + get_parametrize_args . This can be handy for debugging purposes. # Collect all cases cases_funs = get_all_cases ( f , cases = cases , prefix = prefix , glob = glob , has_tag = has_tag , filter = filter ) # Transform the various functions found argvalues = get_parametrize_args ( cases_funs ) Parameters argnames : same than in @pytest.mark.parametrize cases : a case function, a class containing cases, a module object or a module name string (relative module names accepted). Or a list of such items. You may use THIS_MODULE or '.' to include current module. AUTO (default) means that the module named test_<name>_cases.py will be loaded, where test_<name>.py is the module file of the decorated function. AUTO2 allows you to use the alternative naming scheme case_<name>.py . When a module is listed, all of its functions matching the prefix , filter and has_tag are selected, including those functions nested in classes following naming pattern *Case* . When classes are explicitly provided in the list, they can have any name and do not need to follow this *Case* pattern. prefix : the prefix for case functions. Default is 'case_' but you might wish to use different prefixes to denote different kind of cases, for example 'data_', 'algo_', 'user_', etc. glob : an optional glob-like pattern for case ids, for example \" _success\" or \" _failure\". Note that this is applied on the case id, and therefore if it is customized through @case(id=...) it should be taken into account. has_tag : a single tag or a tuple, set, list of tags that should be matched by the ones set with the @case decorator on the case function(s) to be selected. filter : a callable receiving the case function and returning True or a truth value in case the function needs to be selected.","title":"@parametrize_with_cases"},{"location":"api_reference/#get_all_cases","text":"def get_all_cases ( parametrization_target : Callable , cases : Union [ Callable , Type , ModuleRef ] = None , prefix : str = 'case_' , glob : str = None , has_tag : Union [ str , Iterable [ str ]] = None , filter : Callable [[ Callable ], bool ] = None ) -> List [ Callable ]: Lists all desired cases for a given parametrization_target (a test function or a fixture). This function may be convenient for debugging purposes. See @parametrize_with_cases for details on the parameters.","title":"get_all_cases"},{"location":"api_reference/#get_parametrize_args","text":"def get_parametrize_args ( cases_funs : List [ Callable ], ) -> List [ Union [ lazy_value , fixture_ref ]]: Transforms a list of cases (obtained from get_all_cases ) into a list of argvalues for @parametrize . Each case function case_fun is transformed into one or several lazy_value (s) or a fixture_ref : If case_fun requires at least on fixture, a fixture will be created if not yet present, and a fixture_ref will be returned. If case_fun is a parametrized case, one lazy_value with a partialized version will be created for each parameter combination. Otherwise, case_fun represents a single case: in that case a single lazy_value is returned.","title":"get_parametrize_args"},{"location":"api_reference/#3-pytest-goodies","text":"","title":"3 - Pytest goodies"},{"location":"api_reference/#fixture","text":"@fixture ( scope : str = \"function\" , autouse : bool = False , name : str = None , unpack_into : Iterable [ str ] = None , hook : Callable = None , ** kwargs ) Identical to @pytest.fixture decorator, except that it supports multi-parametrization with @pytest.mark.parametrize as requested in pytest#3960 . As a consequence it does not support the params and ids arguments anymore. it supports a new argument unpack_into where you can provide names for fixtures where to unpack this fixture into. As a consequence it does not support the params and ids arguments anymore. Parameters: scope : the scope for which this fixture is shared, one of \"function\" (default), \"class\", \"module\" or \"session\". autouse : if True, the fixture func is activated for all tests that can see it. If False (the default) then an explicitreference is needed to activate the fixture. name : the name of the fixture. This defaults to the name of the decorated function. Note: If a fixture is used in the same module in which it is defined, the function name of the fixture will be shadowed by the function arg that requests the fixture; one wayto resolve this is to name the decorated function fixture_<fixturename> and then use @pytest.fixture(name='<fixturename>') . unpack_into : an optional iterable of names, or string containing coma-separated names, for additional fixtures to create to represent parts of this fixture. See unpack_fixture for details. hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. kwargs : other keyword arguments for @pytest.fixture","title":"@fixture"},{"location":"api_reference/#unpack_fixture","text":"def unpack_fixture ( argnames : str , fixture : Union [ str , Callable ], hook : Callable = None ) -> Tuple [ < Fixture > ] Creates several fixtures with names argnames from the source fixture . Created fixtures will correspond to elements unpacked from fixture in order. For example if fixture is a tuple of length 2, argnames=\"a,b\" will create two fixtures containing the first and second element respectively. The created fixtures are automatically registered into the callers' module, but you may wish to assign them to variables for convenience. In that case make sure that you use the same names, e.g. a, b = unpack_fixture('a,b', 'c') . import pytest from pytest_cases import unpack_fixture , fixture_plus @fixture_plus @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] a , b = unpack_fixture ( \"a,b\" , c ) def test_function ( a , b ): assert a [ 0 ] == b Parameters argnames : same as @pytest.mark.parametrize argnames . fixture : a fixture name string or a fixture symbol. If a fixture symbol is provided, the created fixtures will have the same scope. If a name is provided, they will have scope='function'. Note that in practice the performance loss resulting from using function rather than a higher scope is negligible since the created fixtures' body is a one-liner. hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. Outputs: the created fixtures.","title":"unpack_fixture"},{"location":"api_reference/#fixture_union","text":"def fixture_union ( name : str , fixtures : Iterable [ Union [ str , Callable ]], scope : str = \"function\" , idstyle : Optional [ str ] = 'explicit' , ids : Union [ Callable , List [ str ]] = None , unpack_into : Iterable [ str ] = None , autouse : bool = False , hook : Callable = None , ** kwargs ) -> < Fixture > Creates a fixture that will take all values of the provided fixtures in order. That fixture is automatically registered into the callers' module, but you may wish to assign it to a variable for convenience. In that case make sure that you use the same name, e.g. a = fixture_union('a', ['b', 'c']) The style of test ids corresponding to the union alternatives can be changed with idstyle . Three values are allowed: 'explicit' (default) favors readability, 'compact' adds a small mark so that at least one sees which parameters are union parameters and which others are normal parameters, None does not change the ids. Parameters: name : the name of the fixture to create fixtures : an array-like containing fixture names and/or fixture symbols scope : the scope of the union. Since the union depends on the sub-fixtures, it should be smaller than the smallest scope of fixtures referenced. idstyle : The style of test ids corresponding to the union alternatives. One of 'explicit' (default), 'compact' , or None . unpack_into : an optional iterable of names, or string containing coma-separated names, for additional fixtures to create to represent parts of this fixture. See unpack_fixture for details. ids : as in pytest. The default value returns the correct fixture autouse : as in pytest hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. kwargs : other pytest fixture options. They might not be supported correctly. Outputs: the new fixture. Note: you do not need to capture that output in a symbol, since the fixture is automatically registered in your module. However if you decide to do so make sure that you use the same name.","title":"fixture_union"},{"location":"api_reference/#param_fixtures","text":"def param_fixtures ( argnames : str , argvalues : Iterable [ Any ], autouse : bool = False , ids : Union [ Callable , List [ str ]] = None , scope : str = \"function\" , hook : Callable = None , debug : bool = False , ** kwargs ) -> Tuple [ < Fixture > ] Creates one or several \"parameters\" fixtures - depending on the number or coma-separated names in argnames . The created fixtures are automatically registered into the callers' module, but you may wish to assign them to variables for convenience. In that case make sure that you use the same names, e.g. p, q = param_fixtures('p,q', [(0, 1), (2, 3)]) . Note that the (argnames, argvalues, ids) signature is similar to @pytest.mark.parametrize for consistency, see pytest doc on parametrize . import pytest from pytest_cases import param_fixtures , param_fixture # create a 2-tuple parameter fixture arg1 , arg2 = param_fixtures ( \"arg1, arg2\" , [( 1 , 2 ), ( 3 , 4 )]) @pytest . fixture def fixture_uses_param2 ( arg2 ): ... def test_uses_param2 ( arg1 , arg2 , fixture_uses_param2 ): ... Parameters: argnames : same as @pytest.mark.parametrize argnames . argvalues : same as @pytest.mark.parametrize argvalues . autouse : see fixture autouse ids : same as @pytest.mark.parametrize ids scope : see fixture scope hook : an optional hook to apply to each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store. kwargs : any other argument for the created 'fixtures'","title":"param_fixtures"},{"location":"api_reference/#param_fixture","text":"param_fixture ( argname , argvalues , autouse = False , ids = None , hook = None , scope = \"function\" , ** kwargs ) -> < Fixture > Identical to param_fixtures but for a single parameter name, so that you can assign its output to a single variable.","title":"param_fixture"},{"location":"api_reference/#parametrize","text":"@parametrize_plus ( argnames : str = None , argvalues : Iterable [ Any ] = None , indirect : bool = False , ids : Union [ Callable , List [ str ]] = None , idstyle : str = 'explicit' , idgen : Union [ str , Callable ] = _IDGEN , scope : str = None , hook : Callable = None , debug : bool = False , ** args ) Equivalent to @pytest.mark.parametrize but also supports New alternate style for argnames/argvalues . One can also use **args to pass additional {argnames: argvalues} in the same parametrization call. This can be handy in combination with idgen to master the whole id template associated with several parameters. Note that you can pass coma-separated argnames too, by de-referencing a dict: e.g. **{'a,b': [(0, True), (1, False)], 'c': [-1, 2]} . New alternate style for ids . One can use idgen instead of ids . idgen can be a callable receiving all parameters at once ( **args ) and returning an id ; or it can be a string template using the new-style string formatting where the argnames can be used as variables (e.g. idgen=lambda **args: \"a={a}\".format(**args) or idgen=\"my_id where a={a}\" ). The special idgen=AUTO symbol can be used to generate a default string template equivalent to lambda **args: \"-\".join(\"%s=%s\" % (n, v) for n, v in args.items()) . This is enabled by default if you use the alternate style for argnames/argvalues (e.g. if len(args) > 0 ). New possibilities in argvalues : one can include references to fixtures with fixture_ref(<fixture>) where can be the fixture name or fixture function. When such a fixture reference is detected in the argvalues, a new function-scope \"union\" fixture will be created with a unique name, and the test function will be wrapped so as to be injected with the correct parameters from this fixture. Special test ids will be created to illustrate the switching between the various normal parameters and fixtures. You can see debug print messages about all fixtures created using debug=True one can include lazy argvalues with lazy_value(<valuegetter>, [id=..., marks=...]) . A lazy_value is the same thing than a function-scoped fixture, except that the value getter function is not a fixture and therefore can neither be parametrized nor depend on fixtures. It should have no mandatory argument. Both fixture_ref and lazy_value can be used to represent a single argvalue, or a whole tuple of argvalues when there are several argnames. Several of them can be used in a tuple. Finally, pytest.param is supported even when there are fixture_ref and lazy_value . Here as for all functions above, an optional hook can be passed, to apply on each fixture function that is created during this call. The hook function will be called everytime a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use saved_fixture from pytest-harvest as a hook in order to save all such created fixtures in the fixture store.","title":"@parametrize"},{"location":"api_reference/#lazy_value","text":"def lazy_value ( valuegetter : Callable [[], Any ], id : str = None , marks : Union [ Any , Sequence [ Any ]] = () ) -> LazyValue A reference to a value getter (an argvalue-providing callable), to be used in @parametrize . A lazy_value is the same thing than a function-scoped fixture, except that the value getter function is not a fixture and therefore can neither be parametrized nor depend on fixtures. It should have no mandatory argument. Note that a lazy_value can be included in a pytest.param without problem. In that case the id defined by pytest.param will take precedence over the one defined in lazy_value if any. The marks, however, will all be kept wherever they are defined. Parameters valuegetter : a callable without mandatory arguments id : an optional id. Otherwise valuegetter.__name__ will be used by default marks : optional marks. valuegetter marks will also be preserved.","title":"lazy_value"},{"location":"api_reference/#fixture_ref","text":"def fixture_ref ( fixture : Union [ str , Fixture ] ) A reference to a fixture to be used with @parametrize . Create it with fixture_ref(<fixture>) where can be the fixture name or actual fixture function.","title":"fixture_ref"},{"location":"changelog/","text":"Changelog \u00b6 2.1.2 - Compatibility fix \u00b6 Added support for pytest items without funcargs. Fixes interoperability with other pytest plugins such as pytest-black or pytest-flake8 . Fixes #122 2.1.1 - Fixed issue with pytest 6 \u00b6 pytest 6 is now supported. Fixes #121 2.1.0 - Internal engine improvements + bugfixes \u00b6 Fixed issue with @parametrize_with_cases when two cases with the same id and both requiring a fixture were to be created. Fixed #117 . Fixture closure engine refactoring: When no fixture unions are present, the fixture closure is now identical to the default one in pytest , to avoid issues originating from other plugins fiddling with the closure. Fixes #116 New SuperClosure class representing the \"list\" facade on top of the fixture tree (instead of FixtureClosureNode ). In addition, this list facade now better handles editing the order of fixtures when possible. Fixes #111 . Session and Module-scoped fixtures that are not used in all union alternatives are not any more torn town/setup across union alternatives. Fixes #120 2.0.4 - Bugfix \u00b6 Fixed TypeError with iterable argvalue in standard parametrize. Fixed #115 . 2.0.3 - Bugfixes \u00b6 Fixed wrong module string decomposition when passed to cases argument in @parametrize_with_cases . Fixes #113 Autouse fixtures are now correctly used. Fixed #114 2.0.2 - Better string representation for lazy values \u00b6 Lazy values (so, test cases) now have a much nicer string representation ; in particular in pytest-harvest results tables. Fixes #112 2.0.1 - Better test ids and theory page \u00b6 New documentation page concerning theory of fixture unions. Fixes #109 Using a fixture_ref in a new-style @parametrize (with **args or idgen ) now outputs a correct id. Fixes #110 2.0.0 - Less boilerplate & full pytest alignment \u00b6 I am very pleased to announce this new version of pytest-cases , providing a lot of major improvements. Creating powerful and complex test suites have never been so easy and intuitive ! Below is a complete list of changes, but the user guide has also been updated accordingly so feel free to have a look to get a complete example-based walkthrough. A/ More powerful and flexible cases collection New @parametrize_with_cases decorator to replace @cases_data (deprecated). Aligned with pytest : now argnames can contain several names, and the case functions are automatically unpacked into it. You don't need to perform a case.get() in the test anymore ! @parametrize_with_cases(\"a,b\") def test_foo(a, b): # use a and b directly ! ... cases are unpacked at test setup time, so the clock does not run while the case is created - in case you use pytest-harvest to collect the timings. @parametrize_with_cases can be used on test functions as well as fixture functions (it was already the case in v1) Easier to configure: the decorator now has a single cases argument to indicate the cases, wherever they come from (no module argument anymore) default ( cases=AUTO ) automatically looks for cases in the associated case module named test_xxx_cases.py . Users can easily switch to alternate pattern cases_xxx.py with cases=AUTO2 . Fixes #91 . cases can sit inside a class , like what you're used to do with pytest . This additional style makes it much more convenient to organize cases and associated them with tests, when cases sit in the same file than the tests. Fixes #93 . an explicit sequence can be provided, it can mix all kind of sources : functions, classes, modules, and module names as strings (even relative ones!). @parametrize_with_cases(\"a\", cases=(CasesClass, '.my_extra_cases')) def test_foo(a): ... More powerful API for filtering: a new prefix argument (default case_ ) can be used to define case functions for various type of parameters: welcome user_<id> , data_<id> , algo_<id> , model_<id> ! Fixes #108 a new glob argument receiving a glob-like string can be used to further filter cases based on their names. For example you can distinguish *_success from *_failure case ids, so as to dispatch them to the appropriate positive or negative test. Fixes #108 finally you can still use has_tag and/or provide a filter callable, but now the callable will receive the case function, and this case function has a f._pytestcase attribute containing the id, tags and marks - it is therefore much easier to implement custom filtering. B/ Easier-to-define case functions Case functions can start with different prefixes to denote different kind of data: e.g. data_<id> , user_<id> , model_<id> , etc. Case functions can now be parametrized with @parametrize or @pytest.mark.parametrize , just as in pytest ! This includes the ability to put pytest marks on the whole case, or on some specific parameter values using pytest.param . @cases_generator is therefore now deprecated but its alternate style for ids and arguments definition was preserved in @parametrize , see below. Now case functions can require fixtures ! In that case they will be transformed into fixtures and injected as fixture_ref in the parametrization. Fixes #56 . New single optional @case(id=None, tags=(), marks=()) decorator to replace @case_name and @case_tags (deprecated): a single simple way to customize all aspects of a case function. Also, @test_target completely disappears from the picture as it was just a tag like others - this could be misleading. C/ Misc / pytest goodies New aliases for readability: @fixture for @fixture_plus , and @parametrize for @parametrize_plus (both aliases will coexist with the old names). Fixes #107 . @parametrize was improved in order to support the alternate parametrization mode that was previously offered by @cases_generator , see api reference . That way, users will be able to choose the style of their choice. Fixes #57 and #106 . @parametrize now raises an explicit error message when the user makes a mistake with the argnames. Fixes #105 . More readable error messages in @parametrize when lazy_value does not return the same number of argvalues than expected from the argnames. Any error message associated to a lazy_value function call is not caught and hidden anymore but is emitted to the user, for easier debugging. Fixed issue with lazy_value when a single mark is passed in the constructor. lazy_value used as a tuple for several arguments now have a correct id generated even in old pytest version 2. New pytest goodie assert_exception that can be used as a context manager. Fixes #104 . 1.17.0 - lazy_value improvements + annoying warnings suppression \u00b6 lazy_value are now resolved at pytest setup stage, not pytest call stage. This is important for execution time recorded in the reports (see also pytest-harvest plugin). Fixes #102 A function used as a lazy_value can now be marked with pytest marks. Fixes #99 A lazy_value now has a nicer id when it is a partial. Fixes #97 Removed annoying PytestUnknownMarkWarning warning message when a mark was used on a case. Fixes #100 1.16.0 - New lazy_value for parameters \u00b6 New marker lazy_value for parametrize_plus . Fixes #92 1.15.0 - better parametrize_plus and smaller dependencies \u00b6 Better support for pytest.param in parametrize_plus and also in fixture_union and fixture_param[s] . Improved corresponding ids. Fixed #79 and #86 New @ignore_unused decorator to protect a fixture function from the \"NOT_USED\" case happening when the fixture is used in a fixture union. Removed six , wrapt and enum34 dependencies (Internal) submodules reorganization for readability (Internal) suppressed a lot of code quality warnings 1.14.0 - bugfixes and hook feature \u00b6 Fixed ids precedence order when using pytest.mark.parametrize in a fixture_plus . Fixed #87 Fixed issue with fixture_union when using the same fixture twice in it. Fixes #85 Added the possibility to pass a hook function in all API where fixtures are created behind the scenes, so as to ease debugging and/or save fixtures (with stored_fixture from pytest harvest). Fixes #83 Fixture closures now support reordering when no unions are present. This suppressed the annoying warning \"WARNING the new order is not taken into account !!\" when it was not relevant. Fixes #81 1.13.1 - packaging improvements \u00b6 packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file. Fixes #78 1.13.0 - @cases_generator default names \u00b6 @cases_generator now has a default value for the names template, based on the parameters. Fixes #77 . 1.12.4 - Bugfix \u00b6 Fixed ValueError when a product of unions was used on a test node, for example when two parametrize_plus using fixture_ref s were used on the same fixture or test function. Fixed #76 1.12.3 - Improved error messages \u00b6 Improved error message when something that is not a fixture is used in unpack_fixture or fixture_union . Fixed #75 1.12.2 - Warning fix \u00b6 Fixed deprecation warning #74 1.12.1 - Bugfixes \u00b6 Now using module name and not file path to detect symbols in cases files that are imported from elsewhere and not created locally. Indeed that was causing problems on some ^platforms where a .pyc cache file is created. Fixes #72 Fixed PluginValidationError when pytest_fixture_plus or pytest_parametrize_plus were used in a conftest.py file. Fixes #71 . According to discussion in pytest#6475 , pytest_fixture_plus and pytest_parametrize_plus are now renamed to fixture_plus and parametrize_plus in order for pytest (pluggy) not to think they are hooks. Old aliases will stay around for a few versions, with a deprecation warning. 1.12.0 - better test ids for parametrized tests with fixture refs + bugfix \u00b6 Improved test ids for the cases where fixture_ref is used in the parameters list in @pytest_parametrize_plus . Fixed #69 . Thanks last-partizan for the suggestion ! Fixed TypeError: got an unexpected keyword argument 'indirect' with pytest 5+. Fixed #70 . 1.11.9 - bugfix \u00b6 FixtureClosureNode is now able to properly handle ignore_args , and now supports that plugins append fixtures to the closure, such as pytest-asyncio. Added corresponding tests. Fixes #68 1.11.8 - bugfix \u00b6 Fixed KeyError issue happening when a fixture is not found. Now users will see the \"normal\" error message from pytest ( \"fixture <name> not found\" ). Fixed #67 . 1.11.7 - bugfix \u00b6 Fixed ValueError issue happening with indirectly parametrized fixtures. Fixed #64 . 1.11.6 - pyproject.toml \u00b6 raddessi added a pyproject.toml - thanks! Fixed #65 . 1.11.5 - bugfix \u00b6 pytest_parametrize_plus was not working correctly with test classes, leading to fixture 'self' not found . Fixed #63 . 1.11.4 - python 2 bugfix \u00b6 Fixed issue happening with @pytest.mark.parametrize with python 2. Fixed #62 . 1.11.3 - minor improvements \u00b6 Better error message when users use THIS_MODULE in cases= instead of module= . Added __version__ package-level attribute. 1.11.2 - Increased tolerance to other plugins + bugfix \u00b6 Now when other plugins try to manipulate the fixture closure, warning messages are emitted but no error is raised. Fixed #55 . Also fixed issue #58 happening with doctest. 1.11.1 - Added six dependency explicitly \u00b6 It was missing from setup.py . 1.11.0 - fixture_ref can now be used inside tuples, leading to cross-products \u00b6 Fixes #47 . 1.10.2 - More intuitive error messages \u00b6 Now raising an explicit InvalidParamsList when pytest parametrize argvalues are incorrect. See #54 1.10.1 - Bugfix \u00b6 Fixed #52 . 1.10.0 - New feature: fixtures unpacking \u00b6 You can now unpack a fixture iterable into several individual fixtures using unpack_fixture or using @pytest_fixture_plus(unpack_into=<names>) . This is also available in union_fixture(unpack_into=<names>) . Fixed #50 and #51 . 1.9.3 - Bugfix \u00b6 Fixed issues when parametrize argnames contains a list. This fixed #49 1.9.2 - Bugfix with pytest 3.7 \u00b6 Fixed #48 . 1.9.1 - Bugfix with pytest 3.7 \u00b6 Fixed #48 . 1.9.0 - New --with-reorder commandline option \u00b6 New commandline option '--with-reorder' to change the reordering startegy currently in application. Fixes #45 . The --with-reorder \"skip\" mode was not working correctly in presence of marks, fixed it. Fixed #46 . 1.8.1 - BugFixes \u00b6 Ids should not be used when setting a NOT_USED parametrization. Fixes #43 Fixed issue with ordering and setup/teardown for higher-level scope fixtures (session and module scopes) when using union fixtures. Fixes #44 1.8.0 - Better ids for fixture unions \u00b6 New: fixture_union now accept a non- None value for ids . It also has a new idstyle argument allowing users to change the style of ids used. Finally pytest_parametrize_plus relies on this ids argument to set a more readable list of ids for the created union. Fixes #41 . Misc: Added non-regression test for fixture order. It passes already for all recent pytest versions (after 3.3). Fixes #42 1.7.0 - New @pytest_parametrize_plus allowing fixture references to be used in parameter values \u00b6 New decorator @pytest_parametrize_plus able to handle the case where a fixture_ref(<fixture_name>) is present in the parameter values list. This decorator can be applied both on test functions and fixtures (if they are decorated with @pytest_fixture_plus ). Fixes #40 Major refactoring of the \"union fixtures\" mechanism. The NOT_USED status is now correctly propagated between dependent fixtures. This should fix a few cases where user fixtures were setup/teardown while not used in the current test node. Empty fixture unions are not permitted anymore. The way unions are handled in test parametrization was redesigned. The new design is based on a two-steps approach: first build the fixture closure for each node as a tree (and not a list as in pytest ), and then apply parametrization intelligently based on this tree structure. This fixes several unintuitive behaviours that were happening with unions. Note: interestingly this also fixes pytest#5054 . 1.6.3 - Minor exception enhancement \u00b6 Improved the error message when the name template is wrong in @cases_generator . Fixes #39 . 1.6.2 - bug fixes \u00b6 fixture_union : Changed the repr of NOT_USED to pytest_cases.NOT_USED . @pytest_fixture_plus now correctly handles the NOT_USED when fixtures in the union do not contain any parameter. Fixes #38 . param_fixtures : param_fixtures now delegates to param_fixture when a single parameter name is provided. This is more consistent. Fixed #36 . param_fixture[s] now support all arguments from fixture ( scope and autouse in particular). 1.6.1 - @pytest_fixture_plus improvement to handle NOT_USED cases \u00b6 Fixed issue where fixtures get called with NOT_USED as a parameter when using a fixture_union . This issue is actually only fixed in @pytest_fixture_plus , if you use @pytest.fixture you have to handle it manually. Fixes #37 . 1.6.0 - fixture_union and param_fixture[s] bugfix \u00b6 New fixture_union method to create a fixture that is the union/combination of other fixtures. This is an attempt to solve this pytest proposal . Also, param_fixture and param_fixtures can now be used without necessarily storing the return value into a variable: they will automatically register the created fixtures in the calling module. Finally, fixed a bug with param_fixtures when called to create a fixture for a single parameter. 1.5.1 - param_fixtures bugfix \u00b6 Fixed param_fixtures issue: all parameter values were identical to the last parameter of the tuple. Fixes #32 . 1.5.0 - new helpers param_fixture and param_fixtures \u00b6 Following Sup3rGeo 's proposal, introduced two helper methods to create simple \"parameter fixtures\". Fixes #31 . 1.4.2 - parametrized @pytest_fixture_plus minor bug fix \u00b6 @pytest_fixture_plus now correctly honors parameter id and marks overriden at single parameter level using pytest.param . Fixed #30 . 1.4.1 - parametrized @pytest_fixture_plus minor bug fix \u00b6 Fixed @pytest_fixture_plus in case it is used with parametrize and one parameter is itself customized using pytest.param . Fixed #29 . 1.4.0 - @pytest_fixture_plus major improvement \u00b6 Major improvement of @pytest_fixture_plus : instead of generating fixtures, it now correctly parametrizes the fixture. Skip/fail Marks are correctly copied too. Fixes #28 . pytest_fixture_plus does not accept the params and ids arguments any more, it only relies on parametrization marks. 1.3.3 - parametrized @pytest_fixture_plus Bugfix \u00b6 Fixed minor bug with parametrized @pytest_fixture_plus : spaces are now correctly removed when multiple parameter names are provided in the same parametrize call. Fixes #27 . 1.3.2 - parametrized @pytest_fixture_plus Bugfix \u00b6 Fixed bug with @pytest_fixture_plus when used in parametrized mode. Fixes #26 . Thanks Sup3rGeo ! 1.3.1 - Minor dependency change \u00b6 Now using decopatch to create the decorators. 1.3.0 - More flexible case generators names + Minor dependency change \u00b6 Cases generators can now support explicit name lists, and name generator callables, in addition to the name template strings. Fixed #24 . Dependency to decorator has been dropped and replaced with makefun . Fixed #25 . 1.2.2 - fixed bug with marks on cases with pytest 3.3 \u00b6 Marks on cases are now also working with pytest 3.3. Fixed #23 . Ids for marked tests are now better managed. A new function get_pytest_parametrize_args is now used to transform the list of cases obtained by get_all_cases(module) , into the list of marked cases and ids required by @pytest.mark.parametrize . The doc has been updated to explain this for advanced users wishing to perform this step manually. 1.2.1 - fixed id of test cases with marks \u00b6 Id of test cases with marks was appearing as ParameterSet . Fixed it. 1.2.0 - @pytest.mark can be used on cases + @pytest_fixture_plus parametrization order bugfix \u00b6 Pytest marks such as @pytest.mark.skipif can now be used on case functions. As a consequence, get_all_cases is now the recommended function to use instead of extract_cases_from_module to perform manual collection. Indeed get_all_cases correctly prepares the resulting parameters list so that pytest sees the marks. Fixed #21 . Fixed parametrization order when @pytest_fixture_plus is used with several @pytest.mark.parametrize . Fixed #22 . 1.1.1 - Improved generated fixture names for @pytest_fixture_plus \u00b6 When @pytest_fixture_plus is used on a function marked as parametrized, some fixtures are generated (one for each parameter). Generated fixture names now follow the pattern <fixturename>__<paramname> . Fixed #20 . 1.1.0 - New @pytest_fixture_plus \u00b6 New decorator @pytest_fixture_plus allows to use several @pytest.mark.parametrize on a fixture. Therefore one can use multiple @cases_data decorators, too. Fixes #19 . Note: this is a temporary feature, that will be removed if/when pytest supports it . 1.0.0 - @cases_fixture + pytest 2.x support \u00b6 Pytest 2.x is now supported. Fixes #14 . New feature: @cases_fixture ! Now you can put your cases data retrieval in a fixture so that its duration does not enter into the test duration. This is particularly interesting if you use pytest-harvest to create benchmarks: you probably do not want the case data retrieval/parsing to be counted in the test duration, especially if you use caching on the case function to accelerate subsequent retrievals. Fixes #15 . 0.10.1 - minor encoding issue in setup.py \u00b6 0.10.0 - support for python 2 \u00b6 Python 2 is now supported. Fixed #3 . Note: CaseData , Given , ExpectedNormal , ExpectedError , and MultipleStepsCaseData type hints is not created in python 2 and python<3.5 0.9.1 - pytest-steps is now an independent project \u00b6 Light refactoring: some internal function names are now private, and there are now two submodules. pytest-steps is now an independent project. Examples in the documentation have been updated New documentation page: API reference 0.8.0 - Filtering can now be done using a callable. \u00b6 @cases_data : the filter argument now contains a filtering function. WARNING: the previous behaviour is still available but has been renamed has_tag . Fixes #8 . 0.7.0 - Hardcoded cases selection, and multi-module selection \u00b6 @cases_data has a new parameters cases that can be used to hardcode a case or a list of cases. Its module parameter can also now take a list of modules 0.6.0 - Case parameters and better test suites \u00b6 get_for is deprecated: it was too specific to a given case data format. MultipleStepsCaseData was fixed to also support multiple inputs. Case functions can now have parameters (even case generators). This is particularly useful for test suites. Fixes #9 . 0.5.0 - support for test suites \u00b6 test functions can now be decorated with @test_steps to easily define a test suite with several steps. This fixes #7 . 0.4.0 - support for data caching with lru_cache \u00b6 cases can now be decorated with @lru_cache . @cases_generator also provides a lru_cache parameter to enable caching. Fixes #6 . 0.3.0 - case generators \u00b6 New decorator @cases_generator to define case generators. Fixes #1 . Also, removed unused functions is_expected_error_instance and assert_exception_equal 0.2.0 - THIS_MODULE constant + Tagging/Filtering + doc \u00b6 New constant THIS_MODULE so that cases and test functions can coexist in the same file. This fixes #5 . Added @test_target and @case_tags decorators for case functions, and added filter parameter in @cases_data . This allows users to : tag a case function with any item (and in particular with the reference to the function it relates to), and to filter the case functions used by a test function according to a particular tag. This fixes #4 . Improved documentation 0.1.0 - First public version \u00b6 Initial fork from private repo","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#212-compatibility-fix","text":"Added support for pytest items without funcargs. Fixes interoperability with other pytest plugins such as pytest-black or pytest-flake8 . Fixes #122","title":"2.1.2 - Compatibility fix"},{"location":"changelog/#211-fixed-issue-with-pytest-6","text":"pytest 6 is now supported. Fixes #121","title":"2.1.1 - Fixed issue with pytest 6"},{"location":"changelog/#210-internal-engine-improvements-bugfixes","text":"Fixed issue with @parametrize_with_cases when two cases with the same id and both requiring a fixture were to be created. Fixed #117 . Fixture closure engine refactoring: When no fixture unions are present, the fixture closure is now identical to the default one in pytest , to avoid issues originating from other plugins fiddling with the closure. Fixes #116 New SuperClosure class representing the \"list\" facade on top of the fixture tree (instead of FixtureClosureNode ). In addition, this list facade now better handles editing the order of fixtures when possible. Fixes #111 . Session and Module-scoped fixtures that are not used in all union alternatives are not any more torn town/setup across union alternatives. Fixes #120","title":"2.1.0 - Internal engine improvements + bugfixes"},{"location":"changelog/#204-bugfix","text":"Fixed TypeError with iterable argvalue in standard parametrize. Fixed #115 .","title":"2.0.4 - Bugfix"},{"location":"changelog/#203-bugfixes","text":"Fixed wrong module string decomposition when passed to cases argument in @parametrize_with_cases . Fixes #113 Autouse fixtures are now correctly used. Fixed #114","title":"2.0.3 - Bugfixes"},{"location":"changelog/#202-better-string-representation-for-lazy-values","text":"Lazy values (so, test cases) now have a much nicer string representation ; in particular in pytest-harvest results tables. Fixes #112","title":"2.0.2 - Better string representation for lazy values"},{"location":"changelog/#201-better-test-ids-and-theory-page","text":"New documentation page concerning theory of fixture unions. Fixes #109 Using a fixture_ref in a new-style @parametrize (with **args or idgen ) now outputs a correct id. Fixes #110","title":"2.0.1 - Better test ids and theory page"},{"location":"changelog/#200-less-boilerplate-full-pytest-alignment","text":"I am very pleased to announce this new version of pytest-cases , providing a lot of major improvements. Creating powerful and complex test suites have never been so easy and intuitive ! Below is a complete list of changes, but the user guide has also been updated accordingly so feel free to have a look to get a complete example-based walkthrough. A/ More powerful and flexible cases collection New @parametrize_with_cases decorator to replace @cases_data (deprecated). Aligned with pytest : now argnames can contain several names, and the case functions are automatically unpacked into it. You don't need to perform a case.get() in the test anymore ! @parametrize_with_cases(\"a,b\") def test_foo(a, b): # use a and b directly ! ... cases are unpacked at test setup time, so the clock does not run while the case is created - in case you use pytest-harvest to collect the timings. @parametrize_with_cases can be used on test functions as well as fixture functions (it was already the case in v1) Easier to configure: the decorator now has a single cases argument to indicate the cases, wherever they come from (no module argument anymore) default ( cases=AUTO ) automatically looks for cases in the associated case module named test_xxx_cases.py . Users can easily switch to alternate pattern cases_xxx.py with cases=AUTO2 . Fixes #91 . cases can sit inside a class , like what you're used to do with pytest . This additional style makes it much more convenient to organize cases and associated them with tests, when cases sit in the same file than the tests. Fixes #93 . an explicit sequence can be provided, it can mix all kind of sources : functions, classes, modules, and module names as strings (even relative ones!). @parametrize_with_cases(\"a\", cases=(CasesClass, '.my_extra_cases')) def test_foo(a): ... More powerful API for filtering: a new prefix argument (default case_ ) can be used to define case functions for various type of parameters: welcome user_<id> , data_<id> , algo_<id> , model_<id> ! Fixes #108 a new glob argument receiving a glob-like string can be used to further filter cases based on their names. For example you can distinguish *_success from *_failure case ids, so as to dispatch them to the appropriate positive or negative test. Fixes #108 finally you can still use has_tag and/or provide a filter callable, but now the callable will receive the case function, and this case function has a f._pytestcase attribute containing the id, tags and marks - it is therefore much easier to implement custom filtering. B/ Easier-to-define case functions Case functions can start with different prefixes to denote different kind of data: e.g. data_<id> , user_<id> , model_<id> , etc. Case functions can now be parametrized with @parametrize or @pytest.mark.parametrize , just as in pytest ! This includes the ability to put pytest marks on the whole case, or on some specific parameter values using pytest.param . @cases_generator is therefore now deprecated but its alternate style for ids and arguments definition was preserved in @parametrize , see below. Now case functions can require fixtures ! In that case they will be transformed into fixtures and injected as fixture_ref in the parametrization. Fixes #56 . New single optional @case(id=None, tags=(), marks=()) decorator to replace @case_name and @case_tags (deprecated): a single simple way to customize all aspects of a case function. Also, @test_target completely disappears from the picture as it was just a tag like others - this could be misleading. C/ Misc / pytest goodies New aliases for readability: @fixture for @fixture_plus , and @parametrize for @parametrize_plus (both aliases will coexist with the old names). Fixes #107 . @parametrize was improved in order to support the alternate parametrization mode that was previously offered by @cases_generator , see api reference . That way, users will be able to choose the style of their choice. Fixes #57 and #106 . @parametrize now raises an explicit error message when the user makes a mistake with the argnames. Fixes #105 . More readable error messages in @parametrize when lazy_value does not return the same number of argvalues than expected from the argnames. Any error message associated to a lazy_value function call is not caught and hidden anymore but is emitted to the user, for easier debugging. Fixed issue with lazy_value when a single mark is passed in the constructor. lazy_value used as a tuple for several arguments now have a correct id generated even in old pytest version 2. New pytest goodie assert_exception that can be used as a context manager. Fixes #104 .","title":"2.0.0 - Less boilerplate &amp; full pytest alignment"},{"location":"changelog/#1170-lazy_value-improvements-annoying-warnings-suppression","text":"lazy_value are now resolved at pytest setup stage, not pytest call stage. This is important for execution time recorded in the reports (see also pytest-harvest plugin). Fixes #102 A function used as a lazy_value can now be marked with pytest marks. Fixes #99 A lazy_value now has a nicer id when it is a partial. Fixes #97 Removed annoying PytestUnknownMarkWarning warning message when a mark was used on a case. Fixes #100","title":"1.17.0 - lazy_value improvements + annoying warnings suppression"},{"location":"changelog/#1160-new-lazy_value-for-parameters","text":"New marker lazy_value for parametrize_plus . Fixes #92","title":"1.16.0 - New lazy_value for parameters"},{"location":"changelog/#1150-better-parametrize_plus-and-smaller-dependencies","text":"Better support for pytest.param in parametrize_plus and also in fixture_union and fixture_param[s] . Improved corresponding ids. Fixed #79 and #86 New @ignore_unused decorator to protect a fixture function from the \"NOT_USED\" case happening when the fixture is used in a fixture union. Removed six , wrapt and enum34 dependencies (Internal) submodules reorganization for readability (Internal) suppressed a lot of code quality warnings","title":"1.15.0 - better parametrize_plus and smaller dependencies"},{"location":"changelog/#1140-bugfixes-and-hook-feature","text":"Fixed ids precedence order when using pytest.mark.parametrize in a fixture_plus . Fixed #87 Fixed issue with fixture_union when using the same fixture twice in it. Fixes #85 Added the possibility to pass a hook function in all API where fixtures are created behind the scenes, so as to ease debugging and/or save fixtures (with stored_fixture from pytest harvest). Fixes #83 Fixture closures now support reordering when no unions are present. This suppressed the annoying warning \"WARNING the new order is not taken into account !!\" when it was not relevant. Fixes #81","title":"1.14.0 - bugfixes and hook feature"},{"location":"changelog/#1131-packaging-improvements","text":"packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file. Fixes #78","title":"1.13.1 - packaging improvements"},{"location":"changelog/#1130-cases_generator-default-names","text":"@cases_generator now has a default value for the names template, based on the parameters. Fixes #77 .","title":"1.13.0 - @cases_generator default names"},{"location":"changelog/#1124-bugfix","text":"Fixed ValueError when a product of unions was used on a test node, for example when two parametrize_plus using fixture_ref s were used on the same fixture or test function. Fixed #76","title":"1.12.4 - Bugfix"},{"location":"changelog/#1123-improved-error-messages","text":"Improved error message when something that is not a fixture is used in unpack_fixture or fixture_union . Fixed #75","title":"1.12.3 - Improved error messages"},{"location":"changelog/#1122-warning-fix","text":"Fixed deprecation warning #74","title":"1.12.2 - Warning fix"},{"location":"changelog/#1121-bugfixes","text":"Now using module name and not file path to detect symbols in cases files that are imported from elsewhere and not created locally. Indeed that was causing problems on some ^platforms where a .pyc cache file is created. Fixes #72 Fixed PluginValidationError when pytest_fixture_plus or pytest_parametrize_plus were used in a conftest.py file. Fixes #71 . According to discussion in pytest#6475 , pytest_fixture_plus and pytest_parametrize_plus are now renamed to fixture_plus and parametrize_plus in order for pytest (pluggy) not to think they are hooks. Old aliases will stay around for a few versions, with a deprecation warning.","title":"1.12.1 - Bugfixes"},{"location":"changelog/#1120-better-test-ids-for-parametrized-tests-with-fixture-refs-bugfix","text":"Improved test ids for the cases where fixture_ref is used in the parameters list in @pytest_parametrize_plus . Fixed #69 . Thanks last-partizan for the suggestion ! Fixed TypeError: got an unexpected keyword argument 'indirect' with pytest 5+. Fixed #70 .","title":"1.12.0 - better test ids for parametrized tests with fixture refs + bugfix"},{"location":"changelog/#1119-bugfix","text":"FixtureClosureNode is now able to properly handle ignore_args , and now supports that plugins append fixtures to the closure, such as pytest-asyncio. Added corresponding tests. Fixes #68","title":"1.11.9 - bugfix"},{"location":"changelog/#1118-bugfix","text":"Fixed KeyError issue happening when a fixture is not found. Now users will see the \"normal\" error message from pytest ( \"fixture <name> not found\" ). Fixed #67 .","title":"1.11.8 - bugfix"},{"location":"changelog/#1117-bugfix","text":"Fixed ValueError issue happening with indirectly parametrized fixtures. Fixed #64 .","title":"1.11.7 - bugfix"},{"location":"changelog/#1116-pyprojecttoml","text":"raddessi added a pyproject.toml - thanks! Fixed #65 .","title":"1.11.6 - pyproject.toml"},{"location":"changelog/#1115-bugfix","text":"pytest_parametrize_plus was not working correctly with test classes, leading to fixture 'self' not found . Fixed #63 .","title":"1.11.5 - bugfix"},{"location":"changelog/#1114-python-2-bugfix","text":"Fixed issue happening with @pytest.mark.parametrize with python 2. Fixed #62 .","title":"1.11.4 - python 2 bugfix"},{"location":"changelog/#1113-minor-improvements","text":"Better error message when users use THIS_MODULE in cases= instead of module= . Added __version__ package-level attribute.","title":"1.11.3 - minor improvements"},{"location":"changelog/#1112-increased-tolerance-to-other-plugins-bugfix","text":"Now when other plugins try to manipulate the fixture closure, warning messages are emitted but no error is raised. Fixed #55 . Also fixed issue #58 happening with doctest.","title":"1.11.2 - Increased tolerance to other plugins + bugfix"},{"location":"changelog/#1111-added-six-dependency-explicitly","text":"It was missing from setup.py .","title":"1.11.1 - Added six dependency explicitly"},{"location":"changelog/#1110-fixture_ref-can-now-be-used-inside-tuples-leading-to-cross-products","text":"Fixes #47 .","title":"1.11.0 - fixture_ref can now be used inside tuples, leading to cross-products"},{"location":"changelog/#1102-more-intuitive-error-messages","text":"Now raising an explicit InvalidParamsList when pytest parametrize argvalues are incorrect. See #54","title":"1.10.2 - More intuitive error messages"},{"location":"changelog/#1101-bugfix","text":"Fixed #52 .","title":"1.10.1 - Bugfix"},{"location":"changelog/#1100-new-feature-fixtures-unpacking","text":"You can now unpack a fixture iterable into several individual fixtures using unpack_fixture or using @pytest_fixture_plus(unpack_into=<names>) . This is also available in union_fixture(unpack_into=<names>) . Fixed #50 and #51 .","title":"1.10.0 - New feature: fixtures unpacking"},{"location":"changelog/#193-bugfix","text":"Fixed issues when parametrize argnames contains a list. This fixed #49","title":"1.9.3 - Bugfix"},{"location":"changelog/#192-bugfix-with-pytest-37","text":"Fixed #48 .","title":"1.9.2 - Bugfix with pytest 3.7"},{"location":"changelog/#191-bugfix-with-pytest-37","text":"Fixed #48 .","title":"1.9.1 - Bugfix with pytest 3.7"},{"location":"changelog/#190-new-with-reorder-commandline-option","text":"New commandline option '--with-reorder' to change the reordering startegy currently in application. Fixes #45 . The --with-reorder \"skip\" mode was not working correctly in presence of marks, fixed it. Fixed #46 .","title":"1.9.0 - New --with-reorder commandline option"},{"location":"changelog/#181-bugfixes","text":"Ids should not be used when setting a NOT_USED parametrization. Fixes #43 Fixed issue with ordering and setup/teardown for higher-level scope fixtures (session and module scopes) when using union fixtures. Fixes #44","title":"1.8.1 - BugFixes"},{"location":"changelog/#180-better-ids-for-fixture-unions","text":"New: fixture_union now accept a non- None value for ids . It also has a new idstyle argument allowing users to change the style of ids used. Finally pytest_parametrize_plus relies on this ids argument to set a more readable list of ids for the created union. Fixes #41 . Misc: Added non-regression test for fixture order. It passes already for all recent pytest versions (after 3.3). Fixes #42","title":"1.8.0 - Better ids for fixture unions"},{"location":"changelog/#170-new-pytest_parametrize_plus-allowing-fixture-references-to-be-used-in-parameter-values","text":"New decorator @pytest_parametrize_plus able to handle the case where a fixture_ref(<fixture_name>) is present in the parameter values list. This decorator can be applied both on test functions and fixtures (if they are decorated with @pytest_fixture_plus ). Fixes #40 Major refactoring of the \"union fixtures\" mechanism. The NOT_USED status is now correctly propagated between dependent fixtures. This should fix a few cases where user fixtures were setup/teardown while not used in the current test node. Empty fixture unions are not permitted anymore. The way unions are handled in test parametrization was redesigned. The new design is based on a two-steps approach: first build the fixture closure for each node as a tree (and not a list as in pytest ), and then apply parametrization intelligently based on this tree structure. This fixes several unintuitive behaviours that were happening with unions. Note: interestingly this also fixes pytest#5054 .","title":"1.7.0 - New @pytest_parametrize_plus allowing fixture references to be used in parameter values"},{"location":"changelog/#163-minor-exception-enhancement","text":"Improved the error message when the name template is wrong in @cases_generator . Fixes #39 .","title":"1.6.3 - Minor exception enhancement"},{"location":"changelog/#162-bug-fixes","text":"fixture_union : Changed the repr of NOT_USED to pytest_cases.NOT_USED . @pytest_fixture_plus now correctly handles the NOT_USED when fixtures in the union do not contain any parameter. Fixes #38 . param_fixtures : param_fixtures now delegates to param_fixture when a single parameter name is provided. This is more consistent. Fixed #36 . param_fixture[s] now support all arguments from fixture ( scope and autouse in particular).","title":"1.6.2 - bug fixes"},{"location":"changelog/#161-pytest_fixture_plus-improvement-to-handle-not_used-cases","text":"Fixed issue where fixtures get called with NOT_USED as a parameter when using a fixture_union . This issue is actually only fixed in @pytest_fixture_plus , if you use @pytest.fixture you have to handle it manually. Fixes #37 .","title":"1.6.1 - @pytest_fixture_plus improvement to handle NOT_USED cases"},{"location":"changelog/#160-fixture_union-and-param_fixtures-bugfix","text":"New fixture_union method to create a fixture that is the union/combination of other fixtures. This is an attempt to solve this pytest proposal . Also, param_fixture and param_fixtures can now be used without necessarily storing the return value into a variable: they will automatically register the created fixtures in the calling module. Finally, fixed a bug with param_fixtures when called to create a fixture for a single parameter.","title":"1.6.0 - fixture_union and param_fixture[s] bugfix"},{"location":"changelog/#151-param_fixtures-bugfix","text":"Fixed param_fixtures issue: all parameter values were identical to the last parameter of the tuple. Fixes #32 .","title":"1.5.1 - param_fixtures bugfix"},{"location":"changelog/#150-new-helpers-param_fixture-and-param_fixtures","text":"Following Sup3rGeo 's proposal, introduced two helper methods to create simple \"parameter fixtures\". Fixes #31 .","title":"1.5.0 - new helpers param_fixture and param_fixtures"},{"location":"changelog/#142-parametrized-pytest_fixture_plus-minor-bug-fix","text":"@pytest_fixture_plus now correctly honors parameter id and marks overriden at single parameter level using pytest.param . Fixed #30 .","title":"1.4.2 - parametrized @pytest_fixture_plus minor bug fix"},{"location":"changelog/#141-parametrized-pytest_fixture_plus-minor-bug-fix","text":"Fixed @pytest_fixture_plus in case it is used with parametrize and one parameter is itself customized using pytest.param . Fixed #29 .","title":"1.4.1 - parametrized @pytest_fixture_plus minor bug fix"},{"location":"changelog/#140-pytest_fixture_plus-major-improvement","text":"Major improvement of @pytest_fixture_plus : instead of generating fixtures, it now correctly parametrizes the fixture. Skip/fail Marks are correctly copied too. Fixes #28 . pytest_fixture_plus does not accept the params and ids arguments any more, it only relies on parametrization marks.","title":"1.4.0 - @pytest_fixture_plus major improvement"},{"location":"changelog/#133-parametrized-pytest_fixture_plus-bugfix","text":"Fixed minor bug with parametrized @pytest_fixture_plus : spaces are now correctly removed when multiple parameter names are provided in the same parametrize call. Fixes #27 .","title":"1.3.3 - parametrized @pytest_fixture_plus Bugfix"},{"location":"changelog/#132-parametrized-pytest_fixture_plus-bugfix","text":"Fixed bug with @pytest_fixture_plus when used in parametrized mode. Fixes #26 . Thanks Sup3rGeo !","title":"1.3.2 - parametrized @pytest_fixture_plus Bugfix"},{"location":"changelog/#131-minor-dependency-change","text":"Now using decopatch to create the decorators.","title":"1.3.1 - Minor dependency change"},{"location":"changelog/#130-more-flexible-case-generators-names-minor-dependency-change","text":"Cases generators can now support explicit name lists, and name generator callables, in addition to the name template strings. Fixed #24 . Dependency to decorator has been dropped and replaced with makefun . Fixed #25 .","title":"1.3.0 - More flexible case generators names + Minor dependency change"},{"location":"changelog/#122-fixed-bug-with-marks-on-cases-with-pytest-33","text":"Marks on cases are now also working with pytest 3.3. Fixed #23 . Ids for marked tests are now better managed. A new function get_pytest_parametrize_args is now used to transform the list of cases obtained by get_all_cases(module) , into the list of marked cases and ids required by @pytest.mark.parametrize . The doc has been updated to explain this for advanced users wishing to perform this step manually.","title":"1.2.2 - fixed bug with marks on cases with pytest 3.3"},{"location":"changelog/#121-fixed-id-of-test-cases-with-marks","text":"Id of test cases with marks was appearing as ParameterSet . Fixed it.","title":"1.2.1 - fixed id of test cases with marks"},{"location":"changelog/#120-pytestmark-can-be-used-on-cases-pytest_fixture_plus-parametrization-order-bugfix","text":"Pytest marks such as @pytest.mark.skipif can now be used on case functions. As a consequence, get_all_cases is now the recommended function to use instead of extract_cases_from_module to perform manual collection. Indeed get_all_cases correctly prepares the resulting parameters list so that pytest sees the marks. Fixed #21 . Fixed parametrization order when @pytest_fixture_plus is used with several @pytest.mark.parametrize . Fixed #22 .","title":"1.2.0 - @pytest.mark can be used on cases + @pytest_fixture_plus parametrization order bugfix"},{"location":"changelog/#111-improved-generated-fixture-names-for-pytest_fixture_plus","text":"When @pytest_fixture_plus is used on a function marked as parametrized, some fixtures are generated (one for each parameter). Generated fixture names now follow the pattern <fixturename>__<paramname> . Fixed #20 .","title":"1.1.1 - Improved generated fixture names for @pytest_fixture_plus"},{"location":"changelog/#110-new-pytest_fixture_plus","text":"New decorator @pytest_fixture_plus allows to use several @pytest.mark.parametrize on a fixture. Therefore one can use multiple @cases_data decorators, too. Fixes #19 . Note: this is a temporary feature, that will be removed if/when pytest supports it .","title":"1.1.0 - New @pytest_fixture_plus"},{"location":"changelog/#100-cases_fixture-pytest-2x-support","text":"Pytest 2.x is now supported. Fixes #14 . New feature: @cases_fixture ! Now you can put your cases data retrieval in a fixture so that its duration does not enter into the test duration. This is particularly interesting if you use pytest-harvest to create benchmarks: you probably do not want the case data retrieval/parsing to be counted in the test duration, especially if you use caching on the case function to accelerate subsequent retrievals. Fixes #15 .","title":"1.0.0 - @cases_fixture + pytest 2.x support"},{"location":"changelog/#0101-minor-encoding-issue-in-setuppy","text":"","title":"0.10.1 - minor encoding issue in setup.py"},{"location":"changelog/#0100-support-for-python-2","text":"Python 2 is now supported. Fixed #3 . Note: CaseData , Given , ExpectedNormal , ExpectedError , and MultipleStepsCaseData type hints is not created in python 2 and python<3.5","title":"0.10.0 - support for python 2"},{"location":"changelog/#091-pytest-steps-is-now-an-independent-project","text":"Light refactoring: some internal function names are now private, and there are now two submodules. pytest-steps is now an independent project. Examples in the documentation have been updated New documentation page: API reference","title":"0.9.1 - pytest-steps is now an independent project"},{"location":"changelog/#080-filtering-can-now-be-done-using-a-callable","text":"@cases_data : the filter argument now contains a filtering function. WARNING: the previous behaviour is still available but has been renamed has_tag . Fixes #8 .","title":"0.8.0 - Filtering can now be done using a callable."},{"location":"changelog/#070-hardcoded-cases-selection-and-multi-module-selection","text":"@cases_data has a new parameters cases that can be used to hardcode a case or a list of cases. Its module parameter can also now take a list of modules","title":"0.7.0 - Hardcoded cases selection, and multi-module selection"},{"location":"changelog/#060-case-parameters-and-better-test-suites","text":"get_for is deprecated: it was too specific to a given case data format. MultipleStepsCaseData was fixed to also support multiple inputs. Case functions can now have parameters (even case generators). This is particularly useful for test suites. Fixes #9 .","title":"0.6.0 - Case parameters and better test suites"},{"location":"changelog/#050-support-for-test-suites","text":"test functions can now be decorated with @test_steps to easily define a test suite with several steps. This fixes #7 .","title":"0.5.0 - support for test suites"},{"location":"changelog/#040-support-for-data-caching-with-lru_cache","text":"cases can now be decorated with @lru_cache . @cases_generator also provides a lru_cache parameter to enable caching. Fixes #6 .","title":"0.4.0 - support for data caching with lru_cache"},{"location":"changelog/#030-case-generators","text":"New decorator @cases_generator to define case generators. Fixes #1 . Also, removed unused functions is_expected_error_instance and assert_exception_equal","title":"0.3.0 - case generators"},{"location":"changelog/#020-this_module-constant-taggingfiltering-doc","text":"New constant THIS_MODULE so that cases and test functions can coexist in the same file. This fixes #5 . Added @test_target and @case_tags decorators for case functions, and added filter parameter in @cases_data . This allows users to : tag a case function with any item (and in particular with the reference to the function it relates to), and to filter the case functions used by a test function according to a particular tag. This fixes #4 . Improved documentation","title":"0.2.0 - THIS_MODULE constant + Tagging/Filtering + doc"},{"location":"changelog/#010-first-public-version","text":"Initial fork from private repo","title":"0.1.0 - First public version"},{"location":"examples/","text":"Examples \u00b6 Our examples are hosted in a separate repository so that they can be updated independently. data science benchmark demonstrates how pytest can be used as a benchmarking engine thanks to pytest-cases and pytest-harvest , to compare the performances of several regression algorithms on several datasets and produce various reports (plots, csv table...).","title":"Examples"},{"location":"examples/#examples","text":"Our examples are hosted in a separate repository so that they can be updated independently. data science benchmark demonstrates how pytest can be used as a benchmarking engine thanks to pytest-cases and pytest-harvest , to compare the performances of several regression algorithms on several datasets and produce various reports (plots, csv table...).","title":"Examples"},{"location":"long_description/","text":"pytest-cases \u00b6 Separate test code from test cases in pytest . The documentation for users is available here: https://smarie.github.io/python-pytest-cases/ A readme for developers is available here: https://github.com/smarie/python-pytest-cases","title":"pytest-cases"},{"location":"long_description/#pytest-cases","text":"Separate test code from test cases in pytest . The documentation for users is available here: https://smarie.github.io/python-pytest-cases/ A readme for developers is available here: https://github.com/smarie/python-pytest-cases","title":"pytest-cases"},{"location":"pytest_goodies/","text":"pytest Goodies \u00b6 Many pytest features were missing to make pytest_cases work with such a \"no-boilerplate\" experience. Many of these can be of interest to the general pytest audience, so they are exposed in the public API. @fixture \u00b6 @fixture is similar to pytest.fixture but without its param and ids arguments. Instead, it is able to pick the parametrization from @pytest.mark.parametrize marks applied on fixtures. This makes it very intuitive for users to parametrize both their tests and fixtures. As a bonus, its name argument works even in old versions of pytest (which is not the case for fixture ). Finally it now supports unpacking, see unpacking feature . @fixture deprecation if/when @pytest.fixture supports @pytest.mark.parametrize The ability for pytest fixtures to support the @pytest.mark.parametrize annotation is a feature that clearly belongs to pytest scope, and has been requested already . It is therefore expected that @fixture will be deprecated in favor of @pytest_fixture if/when the pytest team decides to add the proposed feature. As always, deprecation will happen slowly across versions (at least two minor, or one major version update) so as for users to have the time to update their code bases. unpack_fixture / unpack_into \u00b6 In some cases fixtures return a tuple or a list of items. It is not easy to refer to a single of these items in a test or another fixture. With unpack_fixture you can easily do it: import pytest from pytest_cases import unpack_fixture , fixture @fixture @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] a , b = unpack_fixture ( \"a,b\" , c ) def test_function ( a , b ): assert a [ 0 ] == b Note that you can also use the unpack_into= argument of @fixture to do the same thing: import pytest from pytest_cases import fixture @fixture ( unpack_into = \"a,b\" ) @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] def test_function ( a , b ): assert a [ 0 ] == b And it is also available in fixture_union : import pytest from pytest_cases import fixture , fixture_union @fixture @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] @fixture @pytest . mark . parametrize ( \"o\" , [ 'yeepee' , 'yay' ]) def d ( o ): return o , o [ 0 ] fixture_union ( \"c_or_d\" , [ c , d ], unpack_into = \"a, b\" ) def test_function ( a , b ): assert a [ 0 ] == b param_fixture[s] \u00b6 If you wish to share some parameters across several fixtures and tests, it might be convenient to have a fixture representing this parameter. This is relatively easy for single parameters, but a bit harder for parameter tuples. The two utilities functions param_fixture (for a single parameter name) and param_fixtures (for a tuple of parameter names) handle the difficulty for you: import pytest from pytest_cases import param_fixtures , param_fixture # create a single parameter fixture my_parameter = param_fixture ( \"my_parameter\" , [ 1 , 2 , 3 , 4 ]) @pytest . fixture def fixture_uses_param ( my_parameter ): ... def test_uses_param ( my_parameter , fixture_uses_param ): ... # ----- # create a 2-tuple parameter fixture arg1 , arg2 = param_fixtures ( \"arg1, arg2\" , [( 1 , 2 ), ( 3 , 4 )]) @pytest . fixture def fixture_uses_param2 ( arg2 ): ... def test_uses_param2 ( arg1 , arg2 , fixture_uses_param2 ): ... You can mark any of the argvalues with pytest.mark to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in pytest . See pytest documentation . fixture_union \u00b6 As of pytest 5, it is not possible to create a \"union\" fixture, i.e. a parametrized fixture that would first take all the possible values of fixture A, then all possible values of fixture B, etc. Indeed all fixture dependencies (a.k.a. \"closure\") of each test node are grouped together, and if they have parameters a big \"cross-product\" of the parameters is done by pytest . The topic has been largely discussed in pytest-dev#349 and a request for proposal has been finally made. fixture_union is an implementation of this proposal. It is also used by parametrize to support fixture_ref in parameter values, see below . The theory is presented in more details in this page , while below are more practical examples. from pytest_cases import fixture , fixture_union @fixture def first (): return 'hello' @fixture ( params = [ 'a' , 'b' ]) def second ( request ): return request . param # c will first take all the values of 'first', then all of 'second' c = fixture_union ( 'c' , [ first , second ]) def test_basic_union ( c ): print ( c ) yields <...>::test_basic_union[c_is_first] hello PASSED <...>::test_basic_union[c_is_second-a] a PASSED <...>::test_basic_union[c_is_second-b] b PASSED As you can see the ids of union fixtures are slightly different from standard ids, so that you can easily understand what is going on. You can change this feature with \u00ecdstyle , see API documentation for details. You can mark any of the alternatives with pytest.mark to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in pytest . See pytest documentation . Fixture unions also support unpacking with the unpack_into argument, see unpacking feature . Fixture unions are a major change in the internal pytest engine, as fixture closures (the ordered set of all fixtures required by a test node to run - directly or indirectly) now become trees where branches correspond to alternative paths taken in the \"unions\", and leafs are the alternative fixture closures. This feature has been tested in very complex cases (several union fixtures, fixtures that are not selected by a given union but that is requested by the test function, etc.). But if you find some strange behaviour don't hesitate to report it in the issues page ! IMPORTANT if you do not use @fixture but only @pytest.fixture , then you will see that your fixtures are called even when they are not used, with a parameter NOT_USED . This symbol is automatically ignored if you use @fixture , otherwise you have to handle it. Alternatively you can use @ignore_unused on your fixture function. fixture unions vs. cases If you're familiar with pytest-cases already, you might note that @cases_data is not so different than a fixture union: we do a union of all case functions. If one day union fixtures are directly supported by pytest , we will probably refactor this lib to align all the concepts. @parametrize \u00b6 @parametrize is a replacement for @pytest.mark.parametrize with many additional features to make the most of parametrization. See API reference for details about all the new features. In particular it allows you to include references to fixtures and to value-generating functions in the parameter values. Simply use fixture_ref(<fixture>) in the parameter values, where <fixture> can be the fixture name or fixture function. if you do not wish to create a fixture, you can also use lazy_value(<function>) Note that when parametrizing several argnames, both fixture_ref and lazy_value can be used as the tuple, or in the tuple. Several fixture_ref and/or lazy_value can be used in the same tuple, too. For example, with a single argument: import pytest from pytest_cases import parametrize , fixture , fixture_ref , lazy_value @pytest . fixture def world_str (): return 'world' def whatfun (): return 'what' @fixture @parametrize ( 'who' , [ fixture_ref ( world_str ), 'you' ]) def greetings ( who ): return 'hello ' + who @parametrize ( 'main_msg' , [ 'nothing' , fixture_ref ( world_str ), lazy_value ( whatfun ), fixture_ref ( greetings )]) @pytest . mark . parametrize ( 'ending' , [ '?' , '!' ]) def test_prints ( main_msg , ending ): print ( main_msg + ending ) yields the following > pytest -s -v collected 10 items test_prints [ main_msg_is_nothing-? ] PASSED [ 10 % ] nothing? test_prints [ main_msg_is_nothing-! ] PASSED [ 20 % ] nothing! test_prints [ main_msg_is_world_str-? ] PASSED [ 30 % ] world? test_prints [ main_msg_is_world_str-! ] PASSED [ 40 % ] world! test_prints [ main_msg_is_whatfun-? ] PASSED [ 50 % ] what? test_prints [ main_msg_is_whatfun-! ] PASSED [ 60 % ] what! test_prints [ main_msg_is_greetings-who_is_world_str-? ] PASSED [ 70 % ] hello world? test_prints [ main_msg_is_greetings-who_is_world_str-! ] PASSED [ 80 % ] hello world! test_prints [ main_msg_is_greetings-who_is_you-? ] PASSED [ 90 % ] hello you? test_prints [ main_msg_is_greetings-who_is_you-! ] PASSED [ 100 % ] hello you! You can also mark any of the argvalues with pytest.mark to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in pytest . See pytest documentation . As you can see in the example above, the default ids are a bit more explicit than usual when you use at least one fixture_ref . This is because the parameters need to be replaced with a fixture union that will \"switch\" between alternative groups of parameters, and the appropriate fixtures referenced. As opposed to fixture_union , the style of these ids is not configurable for now, but feel free to propose alternatives in the issues page . Note that this does not happen if you only use lazy_value s, as they do not require to create a fixture union behind the scenes. Another consequence of using fixture_ref is that the priority order of the parameters, relative to other standard pytest.mark.parametrize parameters that you would place on the same function, will get impacted. You may solve this by replacing your other @pytest.mark.parametrize calls with param_fixture s so that all the parameters are fixtures (see above .) passing a hook \u00b6 As per version 1.14 , all the above functions now support passing a hook argument. This argument should be a callable. It will be called everytime a fixture is about to be created by pytest_cases on your behalf. The fixture function is passed as the argument of the hook, and the hook should return it as the result. You can use this fixture to better understand which fixtures are created behind the scenes, and also to decorate the fixture functions before they are created. For example you can use hook=saved_fixture (from pytest-harvest ) in order to save the created fixtures in the fixture store. assert_exception \u00b6 assert_exception context manager is an alternative to pytest.raises to check exceptions in your tests. You can either check type, instance equality, repr string pattern, or use custom validation functions. See API reference . --with-reorder \u00b6 pytest postprocesses the order of the collected items in order to optimize setup/teardown of session, module and class fixtures. This optimization algorithm happens at the pytest_collection_modifyitems stage, and is still under improvement, as can be seen in pytest#3551 , pytest#3393 , #2846 ... Besides other plugins such as pytest-reorder can modify the order as well. This new commandline is a goodie to change the reordering: --with-reorder normal is the default behaviour: it lets pytest and all the plugins execute their reordering in each of their pytest_collection_modifyitems hooks, and simply does not interact --with-reorder skip allows you to restore the original order that was active before pytest_collection_modifyitems was initially called, thus not taking into account any reordering done by pytest or by any of its plugins.","title":"pytest goodies"},{"location":"pytest_goodies/#pytest-goodies","text":"Many pytest features were missing to make pytest_cases work with such a \"no-boilerplate\" experience. Many of these can be of interest to the general pytest audience, so they are exposed in the public API.","title":"pytest Goodies"},{"location":"pytest_goodies/#fixture","text":"@fixture is similar to pytest.fixture but without its param and ids arguments. Instead, it is able to pick the parametrization from @pytest.mark.parametrize marks applied on fixtures. This makes it very intuitive for users to parametrize both their tests and fixtures. As a bonus, its name argument works even in old versions of pytest (which is not the case for fixture ). Finally it now supports unpacking, see unpacking feature . @fixture deprecation if/when @pytest.fixture supports @pytest.mark.parametrize The ability for pytest fixtures to support the @pytest.mark.parametrize annotation is a feature that clearly belongs to pytest scope, and has been requested already . It is therefore expected that @fixture will be deprecated in favor of @pytest_fixture if/when the pytest team decides to add the proposed feature. As always, deprecation will happen slowly across versions (at least two minor, or one major version update) so as for users to have the time to update their code bases.","title":"@fixture"},{"location":"pytest_goodies/#unpack_fixture-unpack_into","text":"In some cases fixtures return a tuple or a list of items. It is not easy to refer to a single of these items in a test or another fixture. With unpack_fixture you can easily do it: import pytest from pytest_cases import unpack_fixture , fixture @fixture @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] a , b = unpack_fixture ( \"a,b\" , c ) def test_function ( a , b ): assert a [ 0 ] == b Note that you can also use the unpack_into= argument of @fixture to do the same thing: import pytest from pytest_cases import fixture @fixture ( unpack_into = \"a,b\" ) @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] def test_function ( a , b ): assert a [ 0 ] == b And it is also available in fixture_union : import pytest from pytest_cases import fixture , fixture_union @fixture @pytest . mark . parametrize ( \"o\" , [ 'hello' , 'world' ]) def c ( o ): return o , o [ 0 ] @fixture @pytest . mark . parametrize ( \"o\" , [ 'yeepee' , 'yay' ]) def d ( o ): return o , o [ 0 ] fixture_union ( \"c_or_d\" , [ c , d ], unpack_into = \"a, b\" ) def test_function ( a , b ): assert a [ 0 ] == b","title":"unpack_fixture / unpack_into"},{"location":"pytest_goodies/#param_fixtures","text":"If you wish to share some parameters across several fixtures and tests, it might be convenient to have a fixture representing this parameter. This is relatively easy for single parameters, but a bit harder for parameter tuples. The two utilities functions param_fixture (for a single parameter name) and param_fixtures (for a tuple of parameter names) handle the difficulty for you: import pytest from pytest_cases import param_fixtures , param_fixture # create a single parameter fixture my_parameter = param_fixture ( \"my_parameter\" , [ 1 , 2 , 3 , 4 ]) @pytest . fixture def fixture_uses_param ( my_parameter ): ... def test_uses_param ( my_parameter , fixture_uses_param ): ... # ----- # create a 2-tuple parameter fixture arg1 , arg2 = param_fixtures ( \"arg1, arg2\" , [( 1 , 2 ), ( 3 , 4 )]) @pytest . fixture def fixture_uses_param2 ( arg2 ): ... def test_uses_param2 ( arg1 , arg2 , fixture_uses_param2 ): ... You can mark any of the argvalues with pytest.mark to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in pytest . See pytest documentation .","title":"param_fixture[s]"},{"location":"pytest_goodies/#fixture_union","text":"As of pytest 5, it is not possible to create a \"union\" fixture, i.e. a parametrized fixture that would first take all the possible values of fixture A, then all possible values of fixture B, etc. Indeed all fixture dependencies (a.k.a. \"closure\") of each test node are grouped together, and if they have parameters a big \"cross-product\" of the parameters is done by pytest . The topic has been largely discussed in pytest-dev#349 and a request for proposal has been finally made. fixture_union is an implementation of this proposal. It is also used by parametrize to support fixture_ref in parameter values, see below . The theory is presented in more details in this page , while below are more practical examples. from pytest_cases import fixture , fixture_union @fixture def first (): return 'hello' @fixture ( params = [ 'a' , 'b' ]) def second ( request ): return request . param # c will first take all the values of 'first', then all of 'second' c = fixture_union ( 'c' , [ first , second ]) def test_basic_union ( c ): print ( c ) yields <...>::test_basic_union[c_is_first] hello PASSED <...>::test_basic_union[c_is_second-a] a PASSED <...>::test_basic_union[c_is_second-b] b PASSED As you can see the ids of union fixtures are slightly different from standard ids, so that you can easily understand what is going on. You can change this feature with \u00ecdstyle , see API documentation for details. You can mark any of the alternatives with pytest.mark to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in pytest . See pytest documentation . Fixture unions also support unpacking with the unpack_into argument, see unpacking feature . Fixture unions are a major change in the internal pytest engine, as fixture closures (the ordered set of all fixtures required by a test node to run - directly or indirectly) now become trees where branches correspond to alternative paths taken in the \"unions\", and leafs are the alternative fixture closures. This feature has been tested in very complex cases (several union fixtures, fixtures that are not selected by a given union but that is requested by the test function, etc.). But if you find some strange behaviour don't hesitate to report it in the issues page ! IMPORTANT if you do not use @fixture but only @pytest.fixture , then you will see that your fixtures are called even when they are not used, with a parameter NOT_USED . This symbol is automatically ignored if you use @fixture , otherwise you have to handle it. Alternatively you can use @ignore_unused on your fixture function. fixture unions vs. cases If you're familiar with pytest-cases already, you might note that @cases_data is not so different than a fixture union: we do a union of all case functions. If one day union fixtures are directly supported by pytest , we will probably refactor this lib to align all the concepts.","title":"fixture_union"},{"location":"pytest_goodies/#parametrize","text":"@parametrize is a replacement for @pytest.mark.parametrize with many additional features to make the most of parametrization. See API reference for details about all the new features. In particular it allows you to include references to fixtures and to value-generating functions in the parameter values. Simply use fixture_ref(<fixture>) in the parameter values, where <fixture> can be the fixture name or fixture function. if you do not wish to create a fixture, you can also use lazy_value(<function>) Note that when parametrizing several argnames, both fixture_ref and lazy_value can be used as the tuple, or in the tuple. Several fixture_ref and/or lazy_value can be used in the same tuple, too. For example, with a single argument: import pytest from pytest_cases import parametrize , fixture , fixture_ref , lazy_value @pytest . fixture def world_str (): return 'world' def whatfun (): return 'what' @fixture @parametrize ( 'who' , [ fixture_ref ( world_str ), 'you' ]) def greetings ( who ): return 'hello ' + who @parametrize ( 'main_msg' , [ 'nothing' , fixture_ref ( world_str ), lazy_value ( whatfun ), fixture_ref ( greetings )]) @pytest . mark . parametrize ( 'ending' , [ '?' , '!' ]) def test_prints ( main_msg , ending ): print ( main_msg + ending ) yields the following > pytest -s -v collected 10 items test_prints [ main_msg_is_nothing-? ] PASSED [ 10 % ] nothing? test_prints [ main_msg_is_nothing-! ] PASSED [ 20 % ] nothing! test_prints [ main_msg_is_world_str-? ] PASSED [ 30 % ] world? test_prints [ main_msg_is_world_str-! ] PASSED [ 40 % ] world! test_prints [ main_msg_is_whatfun-? ] PASSED [ 50 % ] what? test_prints [ main_msg_is_whatfun-! ] PASSED [ 60 % ] what! test_prints [ main_msg_is_greetings-who_is_world_str-? ] PASSED [ 70 % ] hello world? test_prints [ main_msg_is_greetings-who_is_world_str-! ] PASSED [ 80 % ] hello world! test_prints [ main_msg_is_greetings-who_is_you-? ] PASSED [ 90 % ] hello you? test_prints [ main_msg_is_greetings-who_is_you-! ] PASSED [ 100 % ] hello you! You can also mark any of the argvalues with pytest.mark to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in pytest . See pytest documentation . As you can see in the example above, the default ids are a bit more explicit than usual when you use at least one fixture_ref . This is because the parameters need to be replaced with a fixture union that will \"switch\" between alternative groups of parameters, and the appropriate fixtures referenced. As opposed to fixture_union , the style of these ids is not configurable for now, but feel free to propose alternatives in the issues page . Note that this does not happen if you only use lazy_value s, as they do not require to create a fixture union behind the scenes. Another consequence of using fixture_ref is that the priority order of the parameters, relative to other standard pytest.mark.parametrize parameters that you would place on the same function, will get impacted. You may solve this by replacing your other @pytest.mark.parametrize calls with param_fixture s so that all the parameters are fixtures (see above .)","title":"@parametrize"},{"location":"pytest_goodies/#passing-a-hook","text":"As per version 1.14 , all the above functions now support passing a hook argument. This argument should be a callable. It will be called everytime a fixture is about to be created by pytest_cases on your behalf. The fixture function is passed as the argument of the hook, and the hook should return it as the result. You can use this fixture to better understand which fixtures are created behind the scenes, and also to decorate the fixture functions before they are created. For example you can use hook=saved_fixture (from pytest-harvest ) in order to save the created fixtures in the fixture store.","title":"passing a hook"},{"location":"pytest_goodies/#assert_exception","text":"assert_exception context manager is an alternative to pytest.raises to check exceptions in your tests. You can either check type, instance equality, repr string pattern, or use custom validation functions. See API reference .","title":"assert_exception"},{"location":"pytest_goodies/#-with-reorder","text":"pytest postprocesses the order of the collected items in order to optimize setup/teardown of session, module and class fixtures. This optimization algorithm happens at the pytest_collection_modifyitems stage, and is still under improvement, as can be seen in pytest#3551 , pytest#3393 , #2846 ... Besides other plugins such as pytest-reorder can modify the order as well. This new commandline is a goodie to change the reordering: --with-reorder normal is the default behaviour: it lets pytest and all the plugins execute their reordering in each of their pytest_collection_modifyitems hooks, and simply does not interact --with-reorder skip allows you to restore the original order that was active before pytest_collection_modifyitems was initially called, thus not taking into account any reordering done by pytest or by any of its plugins.","title":"--with-reorder"},{"location":"unions_theory/","text":"Theory behind fixture_union \u00b6 1. How pytest works today \u00b6 As of pytest 5, there are three kind of concepts at play to generate the list of test nodes and their received parameters (\"call spec\" in pytest internals). test functions are the functions defined with def test_<name>(<args>) . they can be parametrized using @pytest.mark.parametrize (or our enhanced version @parametrize ). That means that some of the <args> will take several values, and for each combination a distinct test node will be created they can require fixtures , that is, functions decorated with @pytest.fixture (or our enhanced version @fixture ). That means that some of the <args> will take the value of the corresponding fixture(s). fixtures can be parametrized too (with @fixture it is easier :) ), and can require other fixtures. finally fixtures can enable an \"auto-use\" mode, so that they are called even when not explicitly required by anything. Therefore, a test plan can be represented as an acyclic directed graph of fixtures, where nodes are fixtures and edges represent dependencies. On top of this layout, we can overlay the information of which fixture nodes are parametrized, which ones are required by which test function, and which test function is parametrized. The resulting figure is presented below: The following code can be used to easily check the number of tests run. Note that we use @fixture and @parametrize from pytest-cases to ease code readability here but you would get a similar behaviour with @pytest.fixture and @pytest.mark.parametrize (the test ids would not show the parameter names by default though, which is helpful for our demonstration here). from pytest_cases import fixture , parametrize @fixture ( autouse = True ) @parametrize ( ie = [ - 1 , 1 ]) def e ( ie ): return \"e %s \" % ie @fixture def d (): return \"d\" @fixture def c (): return \"c\" @fixture @parametrize ( ia = [ 0 , 1 ]) def a ( c , d , ia ): return \"a %s \" % ia + c + d @parametrize ( i2 = [ 'x' , 'z' ]) def test_2 ( a , i2 ): assert ( a + i2 ) in ( \"a0cdx\" , \"a0cdz\" , \"a1cdx\" , \"a1cdz\" ) @fixture @parametrize ( ib = [ 'x' , 'z' ]) def b ( a , c , ib ): return \"b %s \" % ib + c + a def test_1 ( a , b ): assert a in ( \"a0cd\" , \"a1cd\" ) assert a == b [ - 4 :] assert b [: - 4 ] in ( \"bxc\" , \"bzc\" ) calling pytest yields: ============================= test session starts ============================= collecting ... collected 16 items test_doc_fixture_graph.py::test_2[ie=-1-ia=0-i2=x] test_doc_fixture_graph.py::test_2[ie=-1-ia=0-i2=z] test_doc_fixture_graph.py::test_2[ie=-1-ia=1-i2=x] test_doc_fixture_graph.py::test_2[ie=-1-ia=1-i2=z] test_doc_fixture_graph.py::test_2[ie=1-ia=0-i2=x] test_doc_fixture_graph.py::test_2[ie=1-ia=0-i2=z] test_doc_fixture_graph.py::test_2[ie=1-ia=1-i2=x] test_doc_fixture_graph.py::test_2[ie=1-ia=1-i2=z] test_doc_fixture_graph.py::test_1[ie=-1-ia=0-ib=x] test_doc_fixture_graph.py::test_1[ie=-1-ia=0-ib=z] test_doc_fixture_graph.py::test_1[ie=-1-ia=1-ib=x] test_doc_fixture_graph.py::test_1[ie=-1-ia=1-ib=z] test_doc_fixture_graph.py::test_1[ie=1-ia=0-ib=x] test_doc_fixture_graph.py::test_1[ie=1-ia=0-ib=z] test_doc_fixture_graph.py::test_1[ie=1-ia=1-ib=x] test_doc_fixture_graph.py::test_1[ie=1-ia=1-ib=z] ============================= 16 passed in 0.14s ============================== So each test is called 8 times. How are these calls computed ? first for each test, pytest computes the set of all fixtures that are directly or indirectly required to run it. This is known as the \"fixture closure\". So for test_1 this closure is {a, b, c, d, e} while for test 2 it is {a, c, d, e} . We can show this on the following picture: then a cartesian product is made across the parameters of all parametrization marks found on any item in the closure (including parameters of the test itself), So for test_1 the cartesian product is <ie> x <ia> x <ib> while for test_2 it is <ie> x <ia> x <i2> . This is why both tests result in having 8 variants being called (see details in the test ids above). 2. Extension to fixture unions. \u00b6 A fixture union is by definition a fixture that is parametrized to alternately depend on other fixtures. We will represent this in the figures with a special dashed orange arrow, to remind that a special parameter is associated with the selection of which arrow is activated. Let's consider the following modification of the above example, where we introduce two \"unions\": one as an explicit fixture u , and the other implicitly created by using fixture_ref s in the parametrization of b . We can create such a configuration with a slight modification to the above example: from pytest_cases import fixture , parametrize , fixture_ref , fixture_union ( ... same as above ... ) @fixture @parametrize ( ub = ( fixture_ref ( a ), fixture_ref ( c )), ib = [ 'x' , 'z' ]) def b ( ub , ib ): return \"b %s \" % ib + ub u = fixture_union ( \"u\" , ( a , b )) def test_1 ( u ): pass calling pytest yields: ============================= test session starts ============================= collecting ... collected 24 items test_doc_fixture_graph_union.py::test_2[ie=-1-ia=0-i2=x] PASSED [ 4%] test_doc_fixture_graph_union.py::test_2[ie=-1-ia=0-i2=z] PASSED [ 8%] test_doc_fixture_graph_union.py::test_2[ie=-1-ia=1-i2=x] PASSED [ 12%] test_doc_fixture_graph_union.py::test_2[ie=-1-ia=1-i2=z] PASSED [ 16%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=0-i2=x] PASSED [ 20%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=0-i2=z] PASSED [ 25%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=1-i2=x] PASSED [ 29%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=1-i2=z] PASSED [ 33%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_a-ia=0] PASSED [ 37%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_a-ia=1] PASSED [ 41%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=x-ia=0] PASSED [ 45%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=x-ia=1] PASSED [ 50%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=z-ia=0] PASSED [ 54%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=z-ia=1] PASSED [ 58%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_c-ib=x] PASSED [ 62%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_c-ib=z] PASSED [ 66%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_a-ia=0] PASSED [ 70%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_a-ia=1] PASSED [ 75%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=x-ia=0] PASSED [ 79%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=x-ia=1] PASSED [ 83%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=z-ia=0] PASSED [ 87%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=z-ia=1] PASSED [ 91%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_c-ib=x] PASSED [ 95%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_c-ib=z] PASSED [100%] ======================== 24 passed, 1 warning in 0.30s ======================== Now 24 tests were created ! test_2 still has 8 runs, which is normal as it does not depend on any union fixture. Let's try to understand what happened to parametrization of test_1 . It is actually fairly simple: first a global fixture closure is created as usual, consisting in {u, a, b, c, d, e} then for each union fixture in test_1 's closure, starting from the bottom of the graph, we generate several closures by activating each of the arrows in turn. We progress upwards through the graph of remaining dependencies for each alternative: first u is used to split between subgraphs u_is_a and u_is_b subgraph u_is_a does not contain any union. Its final closure is {u, a, c, d, e} for subgraph u_is_b there is another union. So a new split is generated: subgraph u_is_b-ub_is_a does not contain any union. Its final closure is {u, b, a, c, d, e} subgraph u_is_b-ub_is_c does not contain any union. Its final closure is {u, b, c, e} So the result consists in 3 alternate fixture closures for test_1 : finally, as usual, for each closure a cartesian product is made across the parameters of all parametrization marks found on any item in the closure (including parameters of the test itself), So for test_1 alternative u_is_a , the cartesian product is <ie> x <ia> (4 tests) for test_1 alternative u_is_b-ub_is_a , the cartesian product is <ie> x <ia> x <ib> (8 tests) for test_1 alternative u_is_b-ub_is_c , the cartesian product is <ie> x <ib> (4 tests) for test_2 it is <ie> x <ia> x <i2> . (8 tests). The total is indeed 4 + 8 + 4 + 8 = 24 tests. Once again the test ids may be used to check that everything is correct, see above.","title":"fixture unions theory"},{"location":"unions_theory/#theory-behind-fixture_union","text":"","title":"Theory behind fixture_union"},{"location":"unions_theory/#1-how-pytest-works-today","text":"As of pytest 5, there are three kind of concepts at play to generate the list of test nodes and their received parameters (\"call spec\" in pytest internals). test functions are the functions defined with def test_<name>(<args>) . they can be parametrized using @pytest.mark.parametrize (or our enhanced version @parametrize ). That means that some of the <args> will take several values, and for each combination a distinct test node will be created they can require fixtures , that is, functions decorated with @pytest.fixture (or our enhanced version @fixture ). That means that some of the <args> will take the value of the corresponding fixture(s). fixtures can be parametrized too (with @fixture it is easier :) ), and can require other fixtures. finally fixtures can enable an \"auto-use\" mode, so that they are called even when not explicitly required by anything. Therefore, a test plan can be represented as an acyclic directed graph of fixtures, where nodes are fixtures and edges represent dependencies. On top of this layout, we can overlay the information of which fixture nodes are parametrized, which ones are required by which test function, and which test function is parametrized. The resulting figure is presented below: The following code can be used to easily check the number of tests run. Note that we use @fixture and @parametrize from pytest-cases to ease code readability here but you would get a similar behaviour with @pytest.fixture and @pytest.mark.parametrize (the test ids would not show the parameter names by default though, which is helpful for our demonstration here). from pytest_cases import fixture , parametrize @fixture ( autouse = True ) @parametrize ( ie = [ - 1 , 1 ]) def e ( ie ): return \"e %s \" % ie @fixture def d (): return \"d\" @fixture def c (): return \"c\" @fixture @parametrize ( ia = [ 0 , 1 ]) def a ( c , d , ia ): return \"a %s \" % ia + c + d @parametrize ( i2 = [ 'x' , 'z' ]) def test_2 ( a , i2 ): assert ( a + i2 ) in ( \"a0cdx\" , \"a0cdz\" , \"a1cdx\" , \"a1cdz\" ) @fixture @parametrize ( ib = [ 'x' , 'z' ]) def b ( a , c , ib ): return \"b %s \" % ib + c + a def test_1 ( a , b ): assert a in ( \"a0cd\" , \"a1cd\" ) assert a == b [ - 4 :] assert b [: - 4 ] in ( \"bxc\" , \"bzc\" ) calling pytest yields: ============================= test session starts ============================= collecting ... collected 16 items test_doc_fixture_graph.py::test_2[ie=-1-ia=0-i2=x] test_doc_fixture_graph.py::test_2[ie=-1-ia=0-i2=z] test_doc_fixture_graph.py::test_2[ie=-1-ia=1-i2=x] test_doc_fixture_graph.py::test_2[ie=-1-ia=1-i2=z] test_doc_fixture_graph.py::test_2[ie=1-ia=0-i2=x] test_doc_fixture_graph.py::test_2[ie=1-ia=0-i2=z] test_doc_fixture_graph.py::test_2[ie=1-ia=1-i2=x] test_doc_fixture_graph.py::test_2[ie=1-ia=1-i2=z] test_doc_fixture_graph.py::test_1[ie=-1-ia=0-ib=x] test_doc_fixture_graph.py::test_1[ie=-1-ia=0-ib=z] test_doc_fixture_graph.py::test_1[ie=-1-ia=1-ib=x] test_doc_fixture_graph.py::test_1[ie=-1-ia=1-ib=z] test_doc_fixture_graph.py::test_1[ie=1-ia=0-ib=x] test_doc_fixture_graph.py::test_1[ie=1-ia=0-ib=z] test_doc_fixture_graph.py::test_1[ie=1-ia=1-ib=x] test_doc_fixture_graph.py::test_1[ie=1-ia=1-ib=z] ============================= 16 passed in 0.14s ============================== So each test is called 8 times. How are these calls computed ? first for each test, pytest computes the set of all fixtures that are directly or indirectly required to run it. This is known as the \"fixture closure\". So for test_1 this closure is {a, b, c, d, e} while for test 2 it is {a, c, d, e} . We can show this on the following picture: then a cartesian product is made across the parameters of all parametrization marks found on any item in the closure (including parameters of the test itself), So for test_1 the cartesian product is <ie> x <ia> x <ib> while for test_2 it is <ie> x <ia> x <i2> . This is why both tests result in having 8 variants being called (see details in the test ids above).","title":"1. How pytest works today"},{"location":"unions_theory/#2-extension-to-fixture-unions","text":"A fixture union is by definition a fixture that is parametrized to alternately depend on other fixtures. We will represent this in the figures with a special dashed orange arrow, to remind that a special parameter is associated with the selection of which arrow is activated. Let's consider the following modification of the above example, where we introduce two \"unions\": one as an explicit fixture u , and the other implicitly created by using fixture_ref s in the parametrization of b . We can create such a configuration with a slight modification to the above example: from pytest_cases import fixture , parametrize , fixture_ref , fixture_union ( ... same as above ... ) @fixture @parametrize ( ub = ( fixture_ref ( a ), fixture_ref ( c )), ib = [ 'x' , 'z' ]) def b ( ub , ib ): return \"b %s \" % ib + ub u = fixture_union ( \"u\" , ( a , b )) def test_1 ( u ): pass calling pytest yields: ============================= test session starts ============================= collecting ... collected 24 items test_doc_fixture_graph_union.py::test_2[ie=-1-ia=0-i2=x] PASSED [ 4%] test_doc_fixture_graph_union.py::test_2[ie=-1-ia=0-i2=z] PASSED [ 8%] test_doc_fixture_graph_union.py::test_2[ie=-1-ia=1-i2=x] PASSED [ 12%] test_doc_fixture_graph_union.py::test_2[ie=-1-ia=1-i2=z] PASSED [ 16%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=0-i2=x] PASSED [ 20%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=0-i2=z] PASSED [ 25%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=1-i2=x] PASSED [ 29%] test_doc_fixture_graph_union.py::test_2[ie=1-ia=1-i2=z] PASSED [ 33%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_a-ia=0] PASSED [ 37%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_a-ia=1] PASSED [ 41%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=x-ia=0] PASSED [ 45%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=x-ia=1] PASSED [ 50%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=z-ia=0] PASSED [ 54%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_a-ib=z-ia=1] PASSED [ 58%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_c-ib=x] PASSED [ 62%] test_doc_fixture_graph_union.py::test_1[ie=-1-u_is_b-ub_is_c-ib=z] PASSED [ 66%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_a-ia=0] PASSED [ 70%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_a-ia=1] PASSED [ 75%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=x-ia=0] PASSED [ 79%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=x-ia=1] PASSED [ 83%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=z-ia=0] PASSED [ 87%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_a-ib=z-ia=1] PASSED [ 91%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_c-ib=x] PASSED [ 95%] test_doc_fixture_graph_union.py::test_1[ie=1-u_is_b-ub_is_c-ib=z] PASSED [100%] ======================== 24 passed, 1 warning in 0.30s ======================== Now 24 tests were created ! test_2 still has 8 runs, which is normal as it does not depend on any union fixture. Let's try to understand what happened to parametrization of test_1 . It is actually fairly simple: first a global fixture closure is created as usual, consisting in {u, a, b, c, d, e} then for each union fixture in test_1 's closure, starting from the bottom of the graph, we generate several closures by activating each of the arrows in turn. We progress upwards through the graph of remaining dependencies for each alternative: first u is used to split between subgraphs u_is_a and u_is_b subgraph u_is_a does not contain any union. Its final closure is {u, a, c, d, e} for subgraph u_is_b there is another union. So a new split is generated: subgraph u_is_b-ub_is_a does not contain any union. Its final closure is {u, b, a, c, d, e} subgraph u_is_b-ub_is_c does not contain any union. Its final closure is {u, b, c, e} So the result consists in 3 alternate fixture closures for test_1 : finally, as usual, for each closure a cartesian product is made across the parameters of all parametrization marks found on any item in the closure (including parameters of the test itself), So for test_1 alternative u_is_a , the cartesian product is <ie> x <ia> (4 tests) for test_1 alternative u_is_b-ub_is_a , the cartesian product is <ie> x <ia> x <ib> (8 tests) for test_1 alternative u_is_b-ub_is_c , the cartesian product is <ie> x <ib> (4 tests) for test_2 it is <ie> x <ia> x <i2> . (8 tests). The total is indeed 4 + 8 + 4 + 8 = 24 tests. Once again the test ids may be used to check that everything is correct, see above.","title":"2. Extension to fixture unions."}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pytest-cases","text":"<p>Separate test code from test cases in <code>pytest</code>.</p> <p> </p> <p> </p> <p>Slides from the <code>pytest-cases</code> presentation at EuroPython 2021 are now available here.</p> <p>New <code>current_cases</code> fixture to easily know the current case for each parameter ! See below for details.</p> <p>Did you ever think that most of your test functions were actually the same test code, but with different data inputs and expected results/exceptions ?</p> <ul> <li> <p><code>pytest-cases</code> leverages <code>pytest</code> and its great <code>@pytest.mark.parametrize</code> decorator, so that you can separate your test cases from your test functions.</p> </li> <li> <p>In addition, <code>pytest-cases</code> provides several useful goodies to empower <code>pytest</code>. In particular it improves the fixture mechanism to support \"fixture unions\". This is a major change in the internal <code>pytest</code> engine, unlocking many possibilities such as using fixture references as parameter values in a test function. See here.</p> </li> </ul> <p><code>pytest-cases</code> is fully compliant with pytest-harvest so you can easily monitor the execution times and created artifacts. With it, it becomes very easy to create a complete data science benchmark, for example comparing various models on various datasets as illustrated below (from the example section):</p> <p></p>"},{"location":"#citing","title":"Citing","text":"<p>If <code>pytest-cases</code> helps you with your research work, don't hesitate to spread the word ! For this simply use this Zenodo link  to get the proper citation entry (at the bottom right of the page, many formats available including BibTeX).</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>&gt; pip install pytest-cases\n</code></pre> <p>Note: Installing pytest-cases has effects on the order of <code>pytest</code> tests execution, even if you do not use its features. One positive side effect is that it fixed pytest#5054. But if you see less desirable ordering please report it.</p>"},{"location":"#why-pytest-cases","title":"Why <code>pytest-cases</code> ?","text":"<p><code>pytest</code> philosophy</p> <p>Let's consider the following <code>foo</code> function under test, located in <code>example.py</code>:</p> <pre><code>def foo(a, b):\n    return a + 1, b + 1\n</code></pre> <p>If we were using plain <code>pytest</code> to test it with various inputs, we would create a <code>test_foo.py</code> file and use <code>@pytest.mark.parametrize</code>:</p> <pre><code>import pytest\nfrom example import foo\n\n@pytest.mark.parametrize(\"a,b\", [(1, 2), (-1, -2)])\ndef test_foo(a, b):\n    # check that foo runs correctly and that the result is a tuple. \n    assert isinstance(foo(a, b), tuple)\n</code></pre> <p>This is the fastest and most compact thing to do when you have a few number of test cases, that do not require code to generate each test case. </p> <p><code>pytest</code> current limitations</p> <p>Now imagine that instead of <code>(1, 2)</code> and <code>(-1, -2)</code> each of our test cases </p> <ul> <li>requires a few lines of code to be generated. For example artificial data creation using <code>numpy</code> and/or <code>pandas</code>:</li> </ul> <pre><code>import numpy as np\nimport pandas as pd\n\n# case 1: non-sorted uniformly sampled timeseries with 2 holes\ncase1 = pd.DataFrame({\"datetime\": pd.date_range(start='20/1/1', periods=20, \n                                                freq='-1d', tz='UTC'),\n                      \"data1\": np.arange(0, 20),\n                      \"data2\": np.arange(1, 21),\n                      \"data3\": np.arange(1, 21)})\ncase1.drop([3, 12], inplace=True)\n</code></pre> <ul> <li> <p>requires documentation to explain the other developers the intent of that precise test case</p> </li> <li> <p>requires external resources (data files on the filesystem, databases...), with a variable number of cases depending on what is available on the resource - but of course not all the cases would come from the same resource, that would be too easy :).</p> </li> <li> <p>requires a readable <code>id</code>, such as <code>'uniformly_sampled_nonsorted_with_holes'</code> for the above example. Of course we could use <code>pytest.param</code> or <code>ids=&lt;list&gt;</code> but that is \"a pain to maintain\" according to <code>pytest</code> doc (I agree!). Such a design does not feel right as the id is detached from the case.</p> </li> </ul> <p>With standard <code>pytest</code> there is no particular pattern to simplify your life here. Investigating a little bit, people usually end up trying to mix parameters and fixtures and asking this kind of question: so1, so2. But by design it is not possible to solve this problem using fixtures, because <code>pytest</code> does not handle \"unions\" of fixtures.</p> <p>So all in all, the final answer is \"you have to do this yourself\", and have <code>pytest</code> use your handcrafted list of parameters as the list of argvalues in <code>@pytest.mark.parametrize</code>. Typically we would end up creating a <code>get_all_foo_test_cases</code> function, independently from <code>pytest</code>:</p> <pre><code>@pytest.mark.parametrize(\"a,b\", get_all_foo_test_cases())\ndef test_foo(a, b):\n    ...\n</code></pre> <p>There is also an example in <code>pytest</code> doc with a <code>metafunc</code> hook. </p> <p>The issue with such workarounds is that you can do anything. And anything is a bit too much: this does not provide any convention / \"good practice\" on how to organize test cases, which is an open door to developing ad-hoc unreadable or unmaintainable solutions.</p> <p><code>pytest_cases</code> was created to provide an answer to this precise situation. It proposes a simple framework to separate test cases from test functions. The test cases are typically located in a separate \"companion\" file:</p> <ul> <li><code>test_foo.py</code> is your usual test file containing the test functions (named <code>test_&lt;id&gt;</code>),</li> <li><code>test_foo_cases.py</code> contains the test cases, that are also functions (named <code>case_&lt;id&gt;</code> or even <code>&lt;prefix&gt;_&lt;id&gt;</code> if you prefer). Note: an alternate file naming style <code>cases_foo.py</code> is also available if you prefer it.</li> </ul> <p></p> <p>Test cases can also be provided explicitly, for example in a class container:</p> <p></p> <p>And many more as we'll see below.</p>"},{"location":"#basic-usage","title":"Basic usage","text":""},{"location":"#a-case-functions","title":"a- Case functions","text":"<p>Let's create a <code>test_foo_cases.py</code> file. This file will contain test cases generator functions, that we will call case functions for brevity. In these functions, you will typically either parse some test data files, generate some simulated test data, expected results, etc.</p> <pre><code>def case_two_positive_ints():\n    \"\"\" Inputs are two positive integers \"\"\"\n    return 1, 2\n\ndef case_two_negative_ints():\n    \"\"\" Inputs are two negative integers \"\"\"\n    return -1, -2\n</code></pre> <p>Case functions do not have any particular requirement, apart from the default name convention <code>case_&lt;id&gt;</code> - but even that can be customized: you can use distinct prefixes to denote distinct kind of parameters, such as <code>data_&lt;id&gt;</code>, <code>user_&lt;id&gt;</code>, <code>model_&lt;id&gt;</code>... </p> <p>Case functions can return anything that is considered useful to run the associated test. We will see below that you can use all classic pytest mechanism on case functions (id customization, skip/fail marks, parametrization, fixtures injection).</p>"},{"location":"#b-test-functions","title":"b- Test functions","text":"<p>As usual we write our <code>pytest</code> test functions starting with <code>test_</code>, in a <code>test_foo.py</code> file. The only difference is that we now decorate it with <code>@parametrize_with_cases</code> instead of <code>@pytest.mark.parametrize</code> as we were doing previously:</p> <pre><code>from example import foo\nfrom pytest_cases import parametrize_with_cases\n\n@parametrize_with_cases(\"a,b\")\ndef test_foo(a, b):\n    # check that foo runs correctly and that the result is a tuple. \n    assert isinstance(foo(a, b), tuple)\n</code></pre> <p>As simple as that ! The syntax is basically the same than in <code>pytest.mark.parametrize</code>.</p> <p>Executing <code>pytest</code> will now run our test function once for every case function:</p> <pre><code>&gt;&gt;&gt; pytest -s -v\n============================= test session starts =============================\n(...)\n&lt;your_project&gt;/tests/test_foo.py::test_foo[two_positive_ints] PASSED [ 50%]\n&lt;your_project&gt;/tests/test_foo.py::test_foo[two_negative_ints] PASSED [ 100%]\n\n========================== 2 passed in 0.24 seconds ==========================\n</code></pre>"},{"location":"#tools-for-daily-use","title":"Tools for daily use","text":""},{"location":"#a-cases-collection","title":"a- Cases collection","text":""},{"location":"#alternate-sources","title":"Alternate source(s)","text":"<p>It is not mandatory that case functions should be in a different file than the test functions: both can be in the same file. For this you can use <code>cases='.'</code> or <code>cases=THIS_MODULE</code> to refer to the module in which the test function is located:</p> <pre><code>from pytest_cases import parametrize_with_cases\n\ndef case_one_positive_int():\n    return 1\n\ndef case_one_negative_int():\n    return -1\n\n@parametrize_with_cases(\"i\", cases='.')\ndef test_with_this_module(i):\n    assert i == int(i)\n</code></pre> <p>However WARNING: only the case functions defined BEFORE the test function in the module file will be taken into account!</p> <p><code>@parametrize_with_cases(cases=...)</code> also accepts explicit list of case functions, classes containing case functions, and modules. See API Reference for details. A typical way to organize cases is to use classes for example:</p> <pre><code>from pytest_cases import parametrize_with_cases\n\nclass Foo:\n    def case_a_positive_int(self):\n        return 1\n\n    def case_another_positive_int(self):\n        return 2\n\n@parametrize_with_cases(\"a\", cases=Foo)\ndef test_foo(a):\n    assert a &gt; 0\n</code></pre> <p>Note that as for <code>pytest</code>, <code>self</code> is recreated for every test and therefore should not be used to store any useful information. </p>"},{"location":"#alternate-prefix","title":"Alternate prefix","text":"<p><code>case_</code> might not be your preferred prefix, especially if you wish to store in the same module or class various kind of case data. <code>@parametrize_with_cases</code> offers a <code>prefix=...</code> argument to select an alternate prefix for your case functions. That way, you can store in the same module or class case functions as diverse as datasets (e.g. <code>data_</code>), user descriptions (e.g. <code>user_</code>), algorithms or machine learning models (e.g. <code>model_</code> or <code>algo_</code>), etc.</p> <pre><code>from pytest_cases import parametrize_with_cases, parametrize\n\ndef data_a():\n    return 'a'\n\n@parametrize(\"hello\", [True, False])\ndef data_b(hello):\n    return \"hello\" if hello else \"world\"\n\ndef case_c():\n    return dict(name=\"hi i'm not used\")\n\ndef user_bob():\n    return \"bob\"\n\n@parametrize_with_cases(\"data\", cases='.', prefix=\"data_\")\n@parametrize_with_cases(\"user\", cases='.', prefix=\"user_\")\ndef test_with_data(data, user):\n    assert data in ('a', \"hello\", \"world\")\n    assert user == 'bob'\n</code></pre> <p>yields</p> <pre><code>test_doc_filters_n_tags.py::test_with_data[bob-a]       PASSED [ 33%]\ntest_doc_filters_n_tags.py::test_with_data[bob-b-True]   PASSED [ 66%]\ntest_doc_filters_n_tags.py::test_with_data[bob-b-False]   PASSED [ 100%]\n</code></pre>"},{"location":"#filters-and-tags","title":"Filters and tags","text":"<p>The easiest way to select only a subset of case functions in a module or a class, is to specify a custom <code>prefix</code> instead of the default one (<code>'case_'</code>), as shown above.</p> <p>However sometimes more advanced filtering is required. In that case, you can also rely on three additional mechanisms provided in <code>@parametrize_with_cases</code>:</p> <ul> <li>the <code>glob</code> argument can contain a glob-like pattern for case ids. This can become handy to separate for example good or bad cases, the latter returning an expected error type and/or message for use with <code>pytest.raises</code> or with our alternative <code>assert_exception</code>.</li> </ul> <pre><code>from math import sqrt\nimport pytest\nfrom pytest_cases import parametrize_with_cases\n\n\ndef case_int_success():\n    return 1\n\ndef case_negative_int_failure():\n    # note that we decide to return the expected type of failure to check it\n    return -1, ValueError, \"math domain error\"\n\n\n@parametrize_with_cases(\"data\", cases='.', glob=\"*success\")\ndef test_good_datasets(data):\n    assert sqrt(data) &gt; 0\n\n@parametrize_with_cases(\"data, err_type, err_msg\", cases='.', glob=\"*failure\")\ndef test_bad_datasets(data, err_type, err_msg):\n    with pytest.raises(err_type, match=err_msg):\n        sqrt(data)\n</code></pre> <ul> <li>the <code>has_tag</code> argument allows you to filter cases based on tags set on case functions using the <code>@case</code> decorator. See API reference of <code>@case</code> and <code>@parametrize_with_cases</code>.</li> </ul> <pre><code>from pytest_cases import parametrize_with_cases, case\n\nclass FooCases:\n    def case_two_positive_ints(self):\n        return 1, 2\n\n    @case(tags='foo')\n    def case_one_positive_int(self):\n        return 1\n\n@parametrize_with_cases(\"a\", cases=FooCases, has_tag='foo')\ndef test_foo(a):\n    assert a &gt; 0\n</code></pre> <ul> <li>Finally if none of the above matches your expectations, you can provide a callable to <code>filter</code>. This callable will receive each collected case function and should return <code>True</code> (or a truth-value convertible object) in case of success. Note that your function can leverage the <code>get_case_id</code>, <code>get_case_marks</code>, <code>get_case_tags</code> etc. helper functions to read the tags, marks and id found on it. See API doc.</li> </ul> <pre><code>from pytest_cases import get_case_id\n\n@parametrize_with_cases(\"data\", cases='.', \n                        filter=lambda cf: \"success\" in get_case_id(cf))\ndef test_good_datasets2(data):\n    ...\n</code></pre> <ul> <li>An array of default filters is available in the <code>filters</code> module: <code>has_tag</code>, <code>id_has_prefix</code>, etc. You can use logical operations on them such as \"and\" (<code>&amp;</code>) \"or\" (<code>|</code>) and \"not\" (<code>~</code>) in order to create your own custom filters. See API reference for details.</li> </ul> <pre><code>from pytest_cases import filters as ft\n\n\n@parametrize_with_cases(\"data\", cases='.',\n                        filter=ft.has_tag(\"success\") &amp; ft.id_has_prefix(\"case_b\")\ndef test_good_datasets3(data):\n    ...\n</code></pre>"},{"location":"#b-case-functions","title":"b- Case functions","text":""},{"location":"#custom-case-name","title":"Custom case name","text":"<p>The id used by <code>pytest</code> for a given case is automatically taken from the case function name by removing the <code>case_</code> (or other custom) prefix. It can instead be customized explicitly by decorating your case function with the <code>@case(id=&lt;id&gt;)</code> decorator. See API reference.</p> <pre><code>from pytest_cases import case\n\n@case(id=\"2 positive integers\")\ndef case_two_positive_ints():\n    return 1, 2\n</code></pre>"},{"location":"#pytest-marks-skip-xfail","title":"Pytest marks (<code>skip</code>, <code>xfail</code>...)","text":"<p>pytest marks such as <code>@pytest.mark.skipif</code> can be applied on case functions the same way as with test functions.</p> <pre><code>import sys\nimport pytest\n\n@pytest.mark.skipif(sys.version_info &lt; (3, 0), reason=\"Not useful on python 2\")\ndef case_two_positive_ints():\n    return 1, 2\n</code></pre>"},{"location":"#case-generators","title":"Case generators","text":"<p>In many real-world usage we want to generate one test case per <code>&lt;something&gt;</code>. The most intuitive way would be to use a <code>for</code> loop to create the case functions, and to use the <code>@case</code> decorator to set their names ; however this would not be very readable.</p> <p>Instead, case functions can be parametrized the same way as with test functions: simply add the parameter names as arguments in their signature and decorate with <code>@pytest.mark.parametrize</code>. Even better, you can use the enhanced <code>@parametrize</code> from <code>pytest-cases</code> so as to benefit from its additional usability features (see API reference):</p> <pre><code>from pytest_cases import parametrize, parametrize_with_cases\n\nclass CasesFoo:\n    def case_hello(self):\n        return \"hello world\"\n\n    @parametrize(who=('you', 'there'))\n    def case_simple_generator(self, who):\n        return \"hello %s\" % who\n\n\n@parametrize_with_cases(\"msg\", cases=CasesFoo)\ndef test_foo(msg):\n    assert isinstance(msg, str) and msg.startswith(\"hello\")\n</code></pre> <p>Yields</p> <pre><code>test_generators.py::test_foo[hello] PASSED               [ 33%]\ntest_generators.py::test_foo[simple_generator-who=you] PASSED [ 66%]\ntest_generators.py::test_foo[simple_generator-who=there] PASSED [100%]\n</code></pre>"},{"location":"#cases-requiring-fixtures","title":"Cases requiring fixtures","text":"<p>Cases can use fixtures the same way as test functions do: simply add the fixture names as arguments in their signature and make sure the fixture exists or is imported either in the module where <code>@parametrize_with_cases</code> is used, or in a <code>conftest.py</code> file in one of the parent packages. </p> <p>See <code>pytest</code> documentation on sharing fixturesand this blog.</p> <p>You can use the experimental <code>@parametrize_with_cases(import_fixtures=True)</code> argument to perform the import automatically for you, see API reference.</p> <p>Use <code>@fixture</code> instead of <code>@pytest.fixture</code></p> <p>If a fixture is used by some of your cases only, then you should use the <code>@fixture</code> decorator from pytest-cases instead of the standard <code>@pytest.fixture</code>. Otherwise you fixture will be setup/teardown for all cases even those not requiring it. See <code>@fixture</code> doc.</p> <pre><code>from pytest_cases import parametrize_with_cases, fixture, parametrize\n\n@fixture(scope='session')\ndef db():\n    return {0: 'louise', 1: 'bob'}\n\ndef user_bob(db):\n    return db[1]\n\n@parametrize(id=range(2))\ndef user_from_db(db, id):\n    return db[id]\n\n@parametrize_with_cases(\"a\", cases='.', prefix='user_')\ndef test_users(a, db, request):\n    print(\"this is test %r\" % request.node.nodeid)\n    assert a in db.values()\n</code></pre> <p>yields</p> <pre><code>test_fixtures.py::test_users[a_is_bob] \ntest_fixtures.py::test_users[a_is_from_db-id=0] \ntest_fixtures.py::test_users[a_is_from_db-id=1] \n</code></pre>"},{"location":"#advanced-topics","title":"Advanced topics","text":""},{"location":"#a-scope-of-cases","title":"a- Scope of cases","text":"<p>By default a case function is transformed into a lazy parameter using <code>lazy_value</code>. This is not a fixture, but simply a new <code>parametrize</code> mechanism that allows parameters to be provided by functions (See <code>@parametrize</code>).</p> <p>However, as soon as a case function is either parametrized or requires a fixture, then it is automatically transformed into a fixture so that <code>pytest</code> can handle it properly. In that situation, the fixture needs to have a scope. By default this scope is <code>\"function\"</code>. You can change it using the <code>scope</code> argument in <code>@parametrize_with_cases</code>.</p>"},{"location":"#b-parametrizing-fixtures","title":"b- Parametrizing fixtures","text":"<p>In some scenarii you might wish to parametrize a fixture with the cases, rather than the test function. For example </p> <ul> <li> <p>to inject the same test cases in several test functions without duplicating the <code>@parametrize_with_cases</code> decorator on each of them,</p> </li> <li> <p>to generate the test cases once for the whole session, using a <code>scope='session'</code> fixture or another scope,</p> </li> <li> <p>to modify the test cases, log some message, or perform some other action before injecting them into the test functions, and/or after executing the test function (thanks to yield fixtures)</p> </li> <li> <p>...</p> </li> </ul> <p>For this, simply use <code>@fixture</code> from <code>pytest_cases</code> instead of <code>@pytest.fixture</code> to define your fixture. That allows your fixtures to be easily parametrized with <code>@parametrize_with_cases</code>, <code>@parametrize</code>, and even <code>@pytest.mark.parametrize</code>.</p> <pre><code>from pytest_cases import fixture, parametrize_with_cases\n\n@fixture\n@parametrize_with_cases(\"a,b\")\ndef c(a, b):\n    return a + b\n\ndef test_foo(c):\n    assert isinstance(c, int)\n</code></pre>"},{"location":"#c-caching-cases","title":"c- Caching cases","text":"<p>After starting to reuse cases in several test functions, you might end-up thinking \"why do I have to spend the data parsing/generation time several times ? It is the same case.\". </p> <p><code>pytest-cases</code> follows the same philosophy than <code>pytest</code>: each test node should be independent. Therefore case functions are called for each test case. This ensures that mutable objects can not leak across tests, for example.</p> <p>That being said, if you are certain that your tests do not modify your cases data, there are several ways to solve this issue:</p> <ul> <li>the easiest way is to use fixtures with a broad scope, as explained above. However in some parametrization scenarii, <code>pytest</code> does not guarantee that the fixture will be setup only once for the whole session, even if it is a session-scoped fixture. Also the cases will be parsed every time you run pytest, which might be cumbersome</li> </ul> <pre><code>from pytest_cases import parametrize, parametrize_with_cases, fixture\n\n\n@parametrize(a=range(2))\ndef case_dummy(a):\n    # this is read only once per a, while there are 4 test runs \n    return a\n\n@fixture(scope='session')\n@parametrize_with_cases(\"a\", cases='.')\ndef cached_a(a):\n    return a\n\n\n@parametrize(d=range(2))\ndef test_caching(cached_a, d):\n    assert d &lt; 2\n    assert 0 &lt;= cached_a &lt;= 1\n</code></pre> <ul> <li> <p>an alternative is to use <code>functools.lru_cache</code> to explicitly set a memory cache on a case function. For simple cases you could simply decorate your case function with <code>@lru_cache(maxsize=1)</code> since simple case functions do not have arguments. However for case generators this is a bit more tricky to size the cache - the easiest thing is probably to let it to its default size of 128 with the no-argument version <code>@lru_cache</code>, or to remove the max limit and let it auto-grow, with <code>@lru_cache(max_size=None)</code>. See <code>lru_cache</code> documentation for details. Note that an older version of <code>pytest-cases</code> was offering some facilities to set the cache size, this has been removed from the library in version <code>2.0.0</code> as it seemed to provide little added value.</p> </li> <li> <p>finally, you might wish to persist some cases on disk in order for example to avoid downloading them again from their original source, and/or to avoid costly processing on every pytest session. For this, the perfect match for you is to use <code>joblib</code>'s excellent <code>Memory</code> cache. </p> </li> </ul> <p>If you add a cache mechanism, make sure that your test functions do not modify the returned objects !</p>"},{"location":"#d-accessing-the-current-case","title":"d- Accessing the current case","text":"<p>In some scenarii you may wish to access the case functions that are currently used to provide the parameter values. This may be</p> <ul> <li>to make your test behave differently depending on the case function, case id or case tags</li> <li>to <code>pytest.skip</code> some combinations of parameters/cases that do not make sense</li> <li>...</li> </ul> <p>With <code>pytest-cases</code> starting in version <code>3.5</code>, this is now possible thanks to the <code>current_cases</code> fixture. Simply use this fixture to get a dictionary containing the actual parameter id and case function for all parameters parametrized with cases in the current test node. Parametrized fixtures, if any, will appear in a sub-dictionary indexed by the fixture name.</p> <pre><code>from pytest_cases import parametrize, parametrize_with_cases, fixture\n\n@parametrize(nb=(1,))\ndef case_a():\n    return nb\n\n@fixture\n@parametrize_with_cases(\"foo\", cases=case_a)\ndef my_fixture(foo):\n    return foo\n\n@parametrize_with_cases(\"data\", cases=case_a)\ndef test_get_current_case(data, my_fixture, current_cases):\n\n    # access the case details for a test parameter\n    data_id, data_fun, data_params = current_cases[\"data\"]\n\n    # access the case details for a fixture parameter\n    my_fixture_id, my_fixture_fun, my_fixture_params = current_cases[\"my_fixture\"][\"foo\"]\n\n    # let's print all case information for this test node\n    print(current_cases)\n</code></pre> <p>yields</p> <pre><code>{'data': Case(id='a', func=&lt;function case_a at 0x000001C0CAE9E700&gt;, params={'nb': 1}), \n 'my_fixture': {\n     'foo': Case(id='a', func=&lt;function case_a at 0x000001C0CAE9E700&gt;, params={'nb': 1})\n  }}\n</code></pre> <p>As you can see above, details are provided as <code>namedtuple</code>s. When a case itself is parametrized, its current parameter value(s) appear too (in the above example, <code>case_a</code> is parametrized with <code>nb</code>). This can be used to skip a test conditionally, for example:</p> <pre><code>if data_fun is case_a and data_params['nb'] == 1:\n    pytest.skip(\"This specific case is skipped\")\n</code></pre> <p>It can also be used to insert a debug breakpoint for a specific case.</p> <p>To get more information on the case function, you can use <code>get_case_marks(func)</code>, <code>get_case_tags(func)</code>. You can also use <code>matches_tag_query(...)</code> to check if a case function matches some expectations either concerning its id or its tags. See API reference.</p> <p>Note: you can get the same information from a pytest hook, using the <code>get_current_cases</code> function. See API reference for details.</p>"},{"location":"#e-test-ids","title":"e- Test ids","text":"<p>Starting from version 3.0.0, test ids induced by <code>@parametrize_with_cases</code> are similar to the ids induced by <code>@pytest.mark.parametrize</code>, even if a case function is itself parametrized or requires a fixture. In some situations you may wish to get a better control on the test ids.</p> <p>For this you can pass a callable to <code>@parametrize_with_cases(ids=&lt;callable&gt;)</code>. In this callable, you may wish to use <code>get_case_id</code>, <code>get_case_marks</code>, <code>get_case_tags</code>, or <code>matches_tag_query</code> to return a custom id.</p> <pre><code>from pytest_cases import parametrize, parametrize_with_cases, case, get_case_id\n\ndef case_hello():\n    return \"hello !\"\n\n@case(id=\"hello_world\")\ndef case_basic2():\n    return \"hello, world !\"\n\n@case(id=\"hello_name\")\n@parametrize(\"name\", [\"you\", \"earthling\"])\ndef case_basic3(name):\n    return \"hello, %s !\" % name\n\ndef myidgen(case_fun):\n    \"\"\"Custom test case id\"\"\"\n    return \"#%s#\" % get_case_id(case_fun)\n\n@parametrize_with_cases(\"msg\", cases=\".\", ids=myidgen)\ndef test_foo(msg):\n    print(msg)\n</code></pre> <p><code>pytest -s -v</code> yields:</p> <pre><code>============================= test session starts =============================\nplatform win32 -- Python 3.7.3, pytest-5.3.5, py-1.9.0, pluggy-0.13.1\ncachedir: .pytest_cache\n(...)\n\ntest_doc_ids_debug.py::test_foo[#hello#] \ntest_doc_ids_debug.py::test_foo[#hello_world#] \ntest_doc_ids_debug.py::test_foo[#hello_name#-you] \ntest_doc_ids_debug.py::test_foo[#hello_name#-earthling] \n\n============================== 4 passed in 0.07s ==============================\n</code></pre>"},{"location":"#f-debugging","title":"f- Debugging","text":"<p>When all of your case functions are simple, <code>@parametrize_with_cases</code> generates a <code>@parametrize</code> decorator with argvalues being a list of <code>lazy_value(&lt;case_func&gt;)</code> for all of them. This in turn falls back to a good old <code>@pytest.mark.parametrize</code>, so the behaviour is close to what you are used to see when using <code>pytest</code>.</p> <p>However when at least one case function is complex, typically when it requires a fixture, then <code>@parametrize_with_cases</code> wraps it into a fixture and passes a <code>fixture_ref(&lt;fixture_wrapping_case&gt;)</code> to <code>@parametrize</code>. This creates a so-called \"fixture union\": tests are not any more a cross-product of parameters, but a tree. This new feature brought by pytest-cases is not present in <code>pytest</code> by default, and adds a layer of complexity. But good news: starting in pytest-cases 3.0.0, this complexity is entirely hidden. In other words, generated test ids do not differ between this mode, and the simple mode. For debugging purposes however, you might wish to make this visible by setting <code>idstyle</code>:</p> <pre><code>from pytest_cases import parametrize, parametrize_with_cases, case, fixture\n\ndef case_hello():\n    return \"hello !\"\n\n@fixture\n@parametrize(\"_name\", [\"you\", \"earthling\"])\ndef name(_name):\n    return _name\n\n@case(id=\"hello_fixture\")\ndef case_basic3(name):\n    return \"hello, %s !\" % name\n\n@parametrize_with_cases(\"msg\", cases=\".\", idstyle=\"nostyle\")\ndef test_default_idstyle(msg):\n    print(msg)\n\n@parametrize_with_cases(\"msg\", cases=\".\", idstyle=\"compact\")\ndef test_compact_idstyle(msg):\n    print(msg)\n\n@parametrize_with_cases(\"msg\", cases=\".\", idstyle=\"explicit\")\ndef test_explicit_idstyle(msg):\n    print(msg)\n</code></pre> <p><code>pytest -s -v</code> yields</p> <pre><code>test_doc_debug.py::test_default_idstyle[hello] \ntest_doc_debug.py::test_default_idstyle[hello_fixture-you] \ntest_doc_debug.py::test_default_idstyle[hello_fixture-earthling] \ntest_doc_debug.py::test_compact_idstyle[\\hello] \ntest_doc_debug.py::test_compact_idstyle[\\hello_fixture-you] \ntest_doc_debug.py::test_compact_idstyle[\\hello_fixture-earthling] \ntest_doc_debug.py::test_explicit_idstyle[msg\\hello] \ntest_doc_debug.py::test_explicit_idstyle[msg\\hello_fixture-you] \ntest_doc_debug.py::test_explicit_idstyle[msg\\hello_fixture-earthling] \n</code></pre> <p>See also <code>@parametrize</code> documentation for details.</p>"},{"location":"#main-features-benefits","title":"Main features / benefits","text":"<ul> <li> <p>Separation of concerns: test code on one hand, test cases data on the other hand. This is particularly relevant for data science projects where a lot of test datasets are used on the same block of test code.</p> </li> <li> <p>Everything in the test case or in the fixture, not outside. A side-effect of <code>@pytest.mark.parametrize</code> is that users tend to create or parse their datasets outside of the test function. <code>pytest_cases</code> suggests a model where the potentially time and memory consuming step of case data generation/retrieval is performed inside the test node or the required fixture, thus keeping every test case run more independent. It is also easy to put debug breakpoints on specific test cases.</p> </li> <li> <p>User experience fully aligned with pytest. Cases collection and filtering, cases parametrization, cases output unpacking as test arguments, cases using fixtures... all of this will look very familiar to <code>pytest</code> users.</p> </li> </ul>"},{"location":"#see-also","title":"See Also","text":""},{"location":"#pytest","title":"<code>pytest</code>","text":"<ul> <li>pytest documentation on parametrize</li> <li>pytest documentation on fixtures</li> <li>pytest-steps</li> <li>pytest-harvest</li> <li>pytest-patterns for examples showing how to combine the various plugins to create data science benchmarks.</li> </ul>"},{"location":"#others","title":"Others","text":"<ul> <li>makefun is used to dynamically generate functions or modify user-provided function signatures.</li> <li>decopatch is used to create decorators.</li> </ul> <p>Do you like this library ? You might also like my other python libraries </p>"},{"location":"#want-to-contribute","title":"Want to contribute ?","text":"<p>Details on the github page: https://github.com/smarie/python-pytest-cases</p>"},{"location":"api_reference/","title":"API reference","text":"<p>In general, using <code>help(symbol)</code> is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package.</p>"},{"location":"api_reference/#1-fixtures","title":"1 - Fixtures","text":""},{"location":"api_reference/#current_cases","title":"<code>current_cases</code>","text":"<p>A fixture containing <code>get_current_cases(request)</code>.</p> <p>This is a dictionary containing all case parameters for the currently active <code>pytest</code> item. For each test function argument parametrized using a <code>@parametrize_with_case(&lt;argname&gt;, ...)</code> this dictionary contains an entry <code>{&lt;argname&gt;: (case_id, case_function, case_params)}</code>. If several argnames are parametrized this way, a dedicated entry will be present for each argname. The tuple is a <code>namedtuple</code> containing </p> <pre><code> - `id` a string containing the actual case id constructed by `@parametrize_with_cases`.\n - `function` the original case function.\n - `params` a dictionary, containing the parameters of the case, if itself is parametrized. Note that if the\ncase is parametrized with `@parametrize_with_cases`, the associated parameter value in the dictionary will also be\n`(case_id, case_function, case_params)`.\n</code></pre> <p>If a fixture parametrized with cases is active, the dictionary will contain an entry <code>{&lt;fixturename&gt;: &lt;dct&gt;}</code> where <code>&lt;dct&gt;</code> is a dictionary <code>{&lt;argname&gt;: (case_id, case_function, case_params)}</code>.</p> <p>To get more information on a case function, you can use <code>get_case_marks(f)</code>, <code>get_case_tags(f)</code>. You can also use <code>matches_tag_query</code> to check if a case function matches some expectations either concerning its id or its tags. See filters and tags documentation.</p>"},{"location":"api_reference/#2-case-functions","title":"2 - Case functions","text":"<p>As explained in the documentation, case functions have no requirement anymore, and starting from version 2.0.0 of <code>pytest_cases</code> they can be parametrized with the usual <code>@pytest.mark.parametrize</code> or its improvement <code>@parametrize</code>. Therefore the only remaining decorator is the optional <code>@case</code> decorator:</p>"},{"location":"api_reference/#case","title":"<code>@case</code>","text":"<pre><code>@case(id=None,    # type: str  # noqa\n      tags=None,  # type: Union[Any, Iterable[Any]]\n      marks=(),   # type: Union[MarkDecorator, Iterable[MarkDecorator]]\n      )\n</code></pre> <p>Optional decorator for case functions so as to customize some information.</p> <pre><code>@case(id='hey')\ndef case_hi():\n    return 1\n</code></pre> <p>Parameters:</p> <ul> <li> <p><code>id</code>: the custom pytest id that should be used when this case is active. Replaces the deprecated <code>@case_name</code> decorator from v1. If no id is provided, the id is generated from case functions by removing their prefix, see <code>@parametrize_with_cases(prefix='case_')</code>.</p> </li> <li> <p><code>tags</code>: custom tags to be used for filtering in <code>@parametrize_with_cases(has_tags)</code>. Replaces the deprecated <code>@case_tags</code> and <code>@target</code> decorators.</p> </li> <li> <p><code>marks</code>: optional pytest marks to add on the case. Note that decorating the function directly with the mark also works, and if marks are provided in both places they are merged.</p> </li> </ul>"},{"location":"api_reference/#copy_case_info","title":"<code>copy_case_info</code>","text":"<pre><code>def copy_case_info(from_fun,  # type: Callable\n                   to_fun     # type: Callable\n                   ):\n</code></pre> <p>Copies all information from case function <code>from_fun</code> to <code>to_fun</code>.</p>"},{"location":"api_reference/#set_case_id","title":"<code>set_case_id</code>","text":"<pre><code>def set_case_id(id,        # type: str\n                case_func  # type: Callable\n                ):\n</code></pre> <p>Sets an explicit id on case function <code>case_func</code>.</p>"},{"location":"api_reference/#get_case_id","title":"<code>get_case_id</code>","text":"<pre><code>def get_case_id(case_func,                      # type: Callable\n                prefix_for_default_ids='case_'  # type: str\n                ):\n</code></pre> <p>Return the case id associated with this case function.</p> <p>If a custom id is not present, a case id is automatically created from the function name based on removing the provided prefix if present at the beginning of the function name. If the resulting case id is empty, \"\" will be returned. <p>Parameters:</p> <ul> <li> <p><code>case_func</code>: the case function to get a case id for.</p> </li> <li> <p><code>prefix_for_default_ids</code>: this prefix that will be removed if present on the function name to form the default case id.</p> </li> </ul>"},{"location":"api_reference/#get_case_marks","title":"<code>get_case_marks</code>","text":"<pre><code>def get_case_marks(case_func,                         # type: Callable\n                   concatenate_with_fun_marks=False,  # type: bool\n                   as_decorators=False                # type: bool\n                   ):\n</code></pre> <p>Return the marks that are on the case function.</p> <p>There are currently two ways to place a mark on a case function: either with <code>@pytest.mark.&lt;name&gt;</code> or in <code>@case(marks=...)</code>. This function returns a list of marks containing either both (if <code>concatenate_with_fun_marks</code> is <code>True</code>) or only the ones set with <code>@case</code> (<code>concatenate_with_fun_marks</code> is <code>False</code>, default).</p> <p>Parameters:</p> <ul> <li> <p><code>case_func</code>: the case function</p> </li> <li> <p><code>concatenate_with_fun_marks</code>: if <code>False</code> (default) only the marks declared in <code>@case</code> will be returned. Otherwise a concatenation of marks in <code>@case</code> and on the function (for example directly with <code>@pytest.mark.&lt;mk&gt;</code>) will be returned.</p> </li> <li> <p><code>as_decorators</code>: when <code>True</code>, the marks (<code>MarkInfo</code>) will be transformed into <code>MarkDecorators</code> before being returned. Otherwise (default) the marks are returned as is.</p> </li> </ul>"},{"location":"api_reference/#get_case_tags","title":"<code>get_case_tags</code>","text":"<pre><code>def get_case_tags(case_func  # type: Callable\n                  ):\n</code></pre> <p>Return the tags on this case function or an empty tuple.</p> <p>Parameters:</p> <ul> <li><code>case_func</code>: the case function</li> </ul>"},{"location":"api_reference/#matches_tag_query","title":"<code>matches_tag_query</code>","text":"<pre><code>def matches_tag_query(case_fun,      # type: Callable\n                      has_tag=None,  # type: Union[str, Iterable[str]]\n                      filter=None,   # type: Union[Callable[[Callable], bool], Iterable[Callable[[Callable], bool]]]  # noqa\n                      ):\n</code></pre> <p>This function is the one used by <code>@parametrize_with_cases</code> to filter the case functions collected. It can be used manually for tests/debug.</p> <p>Returns True if the case function is selected by the query:</p> <ul> <li> <p>if <code>has_tag</code> contains one or several tags, they should ALL be present in the tags set on <code>case_fun</code> (<code>get_case_tags</code>)</p> </li> <li> <p>if <code>filter</code> contains one or several filter callables, they are all called in sequence and the <code>case_fun</code> is only selected if ALL of them return a <code>True</code> truth value</p> </li> </ul> <p>Parameters:</p> <ul> <li> <p><code>case_fun</code>: the case function</p> </li> <li> <p><code>has_tag</code>: one or several tags that should ALL be present in the tags set on <code>case_fun</code> for it to be selected.</p> </li> <li> <p><code>filter</code>: one or several filter callables that will be called in sequence. If all of them return a <code>True</code> truth value, <code>case_fun</code> is selected.</p> </li> </ul>"},{"location":"api_reference/#is_case_class","title":"<code>is_case_class</code>","text":"<pre><code>def is_case_class(cls,                         # type: Any\n                  case_marker_in_name='Case',  # type: str\n                  check_name=True              # type: bool\n                  ):\n</code></pre> <p>This function is the one used by <code>@parametrize_with_cases</code> to collect cases within classes. It can be used manually for tests/debug.</p> <p>Returns True if the given object is a class and, if <code>check_name=True</code> (default), if its name contains <code>case_marker_in_name</code>.</p> <p>Parameters:</p> <ul> <li> <p><code>cls</code>: the object to check</p> </li> <li> <p><code>case_marker_in_name</code>: the string that should be present in a class name so that it is selected. Default is 'Case'.</p> </li> <li> <p><code>check_name</code>: a boolean (default True) to enforce that the name contains the word <code>case_marker_in_name</code>. If False, any class will lead to a <code>True</code> result whatever its name.</p> </li> </ul>"},{"location":"api_reference/#is_case_function","title":"<code>is_case_function</code>","text":"<pre><code>def is_case_function(f,                 # type: Any\n                     prefix='case_',    # type: str\n                     check_prefix=True  # type: bool\n                     ):\n</code></pre> <p>This function is the one used by <code>@parametrize_with_cases</code> to collect cases. It can be used manually for tests/debug.</p> <p>Returns True if the provided object is a function or callable and, if <code>check_prefix=True</code> (default), if it starts with <code>prefix</code>.</p> <p>Parameters:</p> <ul> <li> <p><code>f</code>: the object to check</p> </li> <li> <p><code>prefix</code>: the string that should be present at the beginning of a function name so that it is selected. Default is 'case_'.</p> </li> <li> <p><code>check_prefix</code>: if this boolean is True (default), the prefix will be checked. If False, any function will lead to a <code>True</code> result whatever its name.</p> </li> </ul>"},{"location":"api_reference/#the-filters-submodule","title":"The <code>filters</code> submodule","text":"<p>This submodule contains symbols to help you create filters for <code>@parametrize_with_cases(filter=...)</code>.</p> <p>All helper filters in this submodule return an instance of <code>CaseFilter</code>, so that you can combine them easily with \"and\" (<code>&amp;</code>) \"or\" (<code>|</code>) and \"invert\" (<code>~</code>) in order to create new custom filters.</p>"},{"location":"api_reference/#has_tag","title":"<code>has_tag</code>","text":"<pre><code>def has_tag(tag_name: str)\n</code></pre> <p>Selects cases that have the tag <code>tag_name</code>. See <code>@case(tags=...)</code> to add tags to a case.</p>"},{"location":"api_reference/#has_tags","title":"<code>has_tags</code>","text":"<pre><code>def has_tags(*tag_names: str)\n</code></pre> <p>Selects cases that have all tags <code>tag_names</code>. See <code>@case(tags=...)</code> to add tags to a case.</p>"},{"location":"api_reference/#id_has_prefix","title":"<code>id_has_prefix</code>","text":"<pre><code>def id_has_prefix(prefix: str)\n</code></pre> <p>Selects cases that have a case id prefix <code>prefix</code>. Note that this is not the prefix of the whole case function name, but the case id, possibly overridden with <code>@case(id=)</code></p>"},{"location":"api_reference/#id_has_suffix","title":"<code>id_has_suffix</code>","text":"<pre><code>def id_has_suffix(suffix: str)\n</code></pre> <p>Selects cases that have a case id suffix <code>suffix</code>. Note that this is not the suffix of the whole case function name, but the case id, possibly overridden with <code>@case(id=)</code></p>"},{"location":"api_reference/#id_match_regex","title":"<code>id_match_regex</code>","text":"<pre><code>def id_match_regex(regex: str)\n</code></pre> <p>Selects cases that have a case id matching regex pattern <code>regex</code>. Note that this is not a match of the whole case function name, but the case id, possibly overridden with <code>@case(id=)</code></p>"},{"location":"api_reference/#casefilter","title":"<code>CaseFilter</code>","text":"<pre><code>CaseFilter(filter_function: Callable)\n</code></pre> <p><code>CaseFilter</code> is the class used by all filters above, and implementing logical operations \"and\" (<code>&amp;</code>) \"or\" (<code>|</code>) and \"not\" (<code>~</code>). You can use it to define a composable filter from any callable receiving a single <code>case</code> argument and returning a boolean indicating if the <code>case</code> is selected.</p>"},{"location":"api_reference/#3-cases-collection","title":"3 - Cases collection","text":""},{"location":"api_reference/#parametrize_with_cases","title":"<code>@parametrize_with_cases</code>","text":"<pre><code>CaseType = Union[Callable, Type, ModuleRef]\n\n@parametrize_with_cases(argnames: str,\n                        cases: Union[CaseType, List[CaseType]] = AUTO,\n                        prefix: str = 'case_',\n                        glob: str = None,\n                        has_tag: Union[str, Iterable[str]] = None,\n                        filter: Callable = None,\n                        ids: Union[Callable, Iterable[str]] = None,\n                        idstyle: Union[str, Callable] = None,\n                        scope: str = \"function\",\n                        import_fixtures: bool = False\n                        )\n</code></pre> <p>A decorator for test functions or fixtures, to parametrize them based on test cases. It works similarly to <code>@pytest.mark.parametrize</code>: argnames represent a coma-separated string of arguments to inject in the decorated test function or fixture. The argument values (<code>argvalues</code> in <code>@pytest.mark.parametrize</code>) are collected from the various case functions found according to <code>cases</code>, and injected as lazy values so that the case functions are called just before the test or fixture is executed.</p> <p>By default (<code>cases=AUTO</code>) the list of test cases is automatically drawn from the python module file named <code>test_&lt;name&gt;_cases.py</code> or if not found, <code>case_&lt;name&gt;.py</code>,  where <code>test_&lt;name&gt;</code> is the current module name.</p> <p>Finally, the <code>cases</code> argument also accepts an explicit case function, cases-containing class, module or module name; or a list containing any mix of these elements. Note that both absolute and relative module names are supported.</p> <p>Note that <code>@parametrize_with_cases</code> collection and parameter creation steps are strictly equivalent to <code>get_all_cases</code> + <code>get_parametrize_args</code>. This can be handy for debugging purposes.</p> <pre><code># Collect all cases\ncases_funs = get_all_cases(f, cases=cases, prefix=prefix,\n                           glob=glob, has_tag=has_tag, filter=filter)\n\n# Transform the various functions found\nargvalues = get_parametrize_args(host_class_or_module_of_f, cases_funs)\n</code></pre> <p>Parameters</p> <ul> <li> <p><code>argnames</code>: same than in <code>@pytest.mark.parametrize</code></p> </li> <li> <p><code>cases</code>: a case function, a class containing cases, a module object or a module name string (relative module names accepted). Or a list of such items. You may use <code>THIS_MODULE</code> or <code>'.'</code> to include current module. <code>AUTO</code> (default) means that the module named <code>test_&lt;name&gt;_cases.py</code> or if not found, <code>case_&lt;name&gt;.py</code>, will be loaded, where <code>test_&lt;name&gt;.py</code> is the module file of the decorated function. When a module is listed, all of its functions matching the <code>prefix</code>, <code>filter</code> and <code>has_tag</code> are selected, including those functions nested in classes following naming pattern <code>*Case*</code>. Nested subclasses are taken into account, as long as they follow the <code>*Case*</code> naming pattern. When classes are explicitly provided in the list, they can have any name and do not need to follow this <code>*Case*</code> pattern.</p> </li> <li> <p><code>prefix</code>: the prefix for case functions. Default is 'case_' but you might wish to use different prefixes to denote different kind of cases, for example 'data_', 'algo_', 'user_', etc.</p> </li> <li> <p><code>glob</code>: a matching pattern for case ids, for example <code>*_success</code> or <code>*_failure</code>. The only special character that can be used for now in this pattern is <code>*</code>, it can not be escaped, and it can be used several times in the same expression. The pattern should match the entire case id for the case to be selected. Note that this is applied on the case id, and therefore if it is customized through <code>@case(id=...)</code> it will be taken into account.</p> </li> <li> <p><code>has_tag</code>: a single tag or a tuple, set, list of tags that should be matched by the ones set with the <code>@case</code> decorator on the case function(s) to be selected.</p> </li> <li> <p><code>filter</code>: a callable receiving the case function and returning <code>True</code> or a truth value in case the function needs to be selected.</p> </li> <li> <p><code>ids</code>: optional custom ids, similar to the one in <code>pytest.mark.parametrize</code>. Users may either provide an iterable of string ids, or a callable. If a callable is provided it will receive the case functions. Users may wish to use <code>get_case_id</code> or other helpers in the API to inspect the case functions.</p> </li> <li> <p><code>idstyle</code>: This is mostly for debug. Style of ids to be used in the \"union\" fixtures generated by <code>@parametrize</code> if some cases are transformed into fixtures behind the scenes. <code>idstyle</code> possible values are <code>'compact'</code>, <code>'explicit'</code> or <code>None</code>/<code>'nostyle'</code> (default), or a callable. <code>idstyle</code> has no effect if no cases are transformed into fixtures. As opposed to <code>ids</code>, a callable provided here will receive a <code>ParamAlternative</code> object indicating which generated fixture should be used. See <code>@parametrize</code> for details.</p> </li> <li> <p><code>scope</code>: The scope of the union fixture to create if <code>fixture_ref</code>s are found in the argvalues</p> </li> <li> <p><code>import_fixtures</code>: experimental feature. Turn this to <code>True</code> in order to automatically import all fixtures defined in the cases module into the current module.</p> </li> </ul>"},{"location":"api_reference/#get_current_cases","title":"<code>get_current_cases</code>","text":"<pre><code>def get_current_cases(request_or_item):\n</code></pre> <p>Returns a dictionary containing all case parameters for the currently active <code>pytest</code> item. You can either pass the <code>pytest</code> item (available in some hooks) or the <code>request</code> (available in hooks, and also directly as a fixture).</p> <p>For each test function argument parametrized using a <code>@parametrize_with_case(&lt;argname&gt;, ...)</code> this dictionary contains an entry <code>{&lt;argname&gt;: (case_id, case_function, case_params)}</code>. If several argnames are parametrized this way, a dedicated entry will be present for each argname. The tuple is a <code>namedtuple</code> containing </p> <pre><code> - `id` a string containing the actual case id constructed by `@parametrize_with_cases`.\n - `function` the original case function.\n - `params` a dictionary, containing the parameters of the case, if itself is parametrized. Note that if the\ncase is parametrized with `@parametrize_with_cases`, the associated parameter value in the dictionary will also be\n`(case_id, case_function, case_params)`.\n</code></pre> <p>If a fixture parametrized with cases is active, the dictionary will contain an entry <code>{&lt;fixturename&gt;: &lt;dct&gt;}</code> where <code>&lt;dct&gt;</code> is a dictionary <code>{&lt;argname&gt;: (case_id, case_function, case_params)}</code>.</p> <p>To get more information on a case function, you can use <code>get_case_id(f)</code>, <code>get_case_marks(f)</code>, <code>get_case_tags(f)</code>. You can also use <code>matches_tag_query</code> to check if a case function matches some expectations either concerning its id or its tags. See filters and tags documentation.</p> <p>Note that you can get the same contents directly by using the <code>current_cases</code> fixture.</p>"},{"location":"api_reference/#get_all_cases","title":"<code>get_all_cases</code>","text":"<p><pre><code>CaseType = Union[Callable, Type, ModuleRef]\n\ndef get_all_cases(parametrization_target: Callable,\n                  cases: Union[CaseType, List[CaseType]] = None,\n                  prefix: str = 'case_',\n                  glob: str = None,\n                  has_tag: Union[str, Iterable[str]] = None,\n                  filter: Callable[[Callable], bool] = None\n                  ) -&gt; List[Callable]:\n</code></pre> Collect all cases as used with <code>@parametrize_with_cases</code>. See <code>@parametrize_with_cases</code> for more details on the parameters. This can be used to lists all desired cases for a given <code>parametrization_target</code> (a test function or a fixture) which may be convenient for debugging purposes.</p> <pre><code># Get the cases for f that are defined in the current file\ncases = get_all_cases(f, cases=\".\")\n\n# Get the cases from cases_xyz.py or test_xyz_cases.py\nimport test.test_xyz\nxyz_cases = get_all_cases(test.test_xyz)\n\n# Can be used to filter explicit cases, in which case no parametrization_target is needed\nfiltered_cases = get_all_cases(cases=[case_1, case_2, case_3], has_tag=[\"banana\"])\n</code></pre> <ul> <li>If using a <code>cases</code> argument that requires module information, such as <code>\".\"</code> <code>AUTO</code> or a relative module like <code>\".xyz\"</code>, the value of <code>parametrization_target</code> will be used to to determine the context.  If <code>None</code> or simply left empty, it will use the module from which <code>get_all_cases</code> was called.  You can pass an explicit module object or a function, in which case the module in which it's defined will be used.</li> </ul>"},{"location":"api_reference/#get_parametrize_args","title":"<code>get_parametrize_args</code>","text":"<pre><code>def get_parametrize_args(host_class_or_module: Union[Type, ModuleType],\n                         cases_funs: List[Callable],\n                         debug: bool = False\n                         ) -&gt; List[Union[lazy_value, fixture_ref]]:\n</code></pre> <p>Transforms a list of cases (obtained from <code>get_all_cases</code>) into a list of argvalues for <code>@parametrize</code>. Each case function <code>case_fun</code> is transformed into one or several <code>lazy_value</code>(s) or a <code>fixture_ref</code>:</p> <ul> <li> <p>If <code>case_fun</code> requires at least on fixture, a fixture will be created if not yet present, and a <code>fixture_ref</code> will be returned.</p> </li> <li> <p>If <code>case_fun</code> is a parametrized case, one <code>lazy_value</code> with a partialized version will be created for each parameter combination.</p> </li> <li> <p>Otherwise, <code>case_fun</code> represents a single case: in that case a single <code>lazy_value</code> is returned.</p> </li> </ul>"},{"location":"api_reference/#4-pytest-goodies","title":"4 - Pytest goodies","text":""},{"location":"api_reference/#fixture","title":"<code>@fixture</code>","text":"<pre><code>@fixture(scope: str = \"function\", \n         autouse: bool = False, \n         name: str = None, \n         unpack_into: Iterable[str] = None,\n         hook: Callable = None,\n         **kwargs)\n</code></pre> <p>Identical to <code>@pytest.fixture</code> decorator, except that </p> <ul> <li> <p>when used in a fixture union (either explicit <code>fixture_union</code> or indirect through <code>@parametrize</code>+<code>fixture_ref</code> or <code>@parametrize_with_cases</code>), it will not be setup/teardown unnecessarily in tests that do not require it.</p> </li> <li> <p>it supports multi-parametrization with <code>@pytest.mark.parametrize</code> as requested in pytest#3960. As a consequence it does not support the <code>params</code> and <code>ids</code> arguments anymore.</p> </li> <li> <p>it supports a new argument <code>unpack_into</code> where you can provide names for fixtures where to unpack this fixture into.</p> </li> </ul> <p>As a consequence it does not support the <code>params</code> and <code>ids</code> arguments anymore.</p> <p>Parameters:</p> <ul> <li>scope: the scope for which this fixture is shared, one of \"function\" (default), \"class\", \"module\" or \"session\".</li> <li>autouse: if True, the fixture func is activated for all tests that can see it.  If False (the default) then an explicitreference is needed to activate the fixture.</li> <li>name: the name of the fixture. This defaults to the name of the decorated function. Note: If a fixture is used in the same module in which it is defined, the function name of the fixture will be shadowed by the function arg that requests the fixture; one wayto resolve this is to name the decorated function <code>fixture_&lt;fixturename&gt;</code> and then use <code>@pytest.fixture(name='&lt;fixturename&gt;')</code>.</li> <li>unpack_into: an optional iterable of names, or string containing coma-separated names, for additional fixtures to create to represent parts of this fixture. See <code>unpack_fixture</code> for details.</li> <li>hook: an optional hook to apply to each fixture function that is created during this call. The hook function will be called every time a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use <code>saved_fixture</code> from <code>pytest-harvest</code> as a hook in order to save all such created fixtures in the fixture store.</li> <li>kwargs: other keyword arguments for <code>@pytest.fixture</code></li> </ul>"},{"location":"api_reference/#unpack_fixture","title":"<code>unpack_fixture</code>","text":"<pre><code>def unpack_fixture(argnames: str,\n                   fixture: Union[str, Callable],\n                   in_cls: bool = False,\n                   hook: Callable = None\n                   ) -&gt; Tuple[&lt;Fixture&gt;, ...]\n</code></pre> <p>Creates several fixtures with names <code>argnames</code> from the source <code>fixture</code>. Created fixtures will correspond to elements unpacked from <code>fixture</code> in order. For example if <code>fixture</code> is a tuple of length 2, <code>argnames=\"a,b\"</code> will create two fixtures containing the first and second element respectively.</p> <p>The created fixtures are automatically registered into the callers' module, but you may wish to assign them to variables for convenience. In that case make sure that you use the same names, e.g. <code>a, b = unpack_fixture('a,b', 'c')</code>.</p> <pre><code>import pytest\nfrom pytest_cases import unpack_fixture, fixture\n\n@fixture\n@pytest.mark.parametrize(\"o\", ['hello', 'world'])\ndef c(o):\n    return o, o[0]\n\na, b = unpack_fixture(\"a,b\", c)\n\ndef test_function(a, b):\n    assert a[0] == b\n</code></pre> <p>You can also use this function inside a class with <code>in_cls=True</code>. In that case you MUST assign the output of the function to variables, as the created fixtures won't be registered with the encompassing module.</p> <pre><code>import pytest\nfrom pytest_cases import unpack_fixture, fixture\n\n@fixture\n@pytest.mark.parametrize(\"o\", ['hello', 'world'])\ndef c(o):\n    return o, o[0]\n\nclass TestClass:\n    a, b = unpack_fixture(\"a,b\", c, in_cls=True)\n\n    def test_function(self, a, b):\n        assert a[0] == b\n</code></pre> <p>Parameters</p> <ul> <li>argnames: same as <code>@pytest.mark.parametrize</code> <code>argnames</code>.</li> <li>fixture: a fixture name string or a fixture symbol. If a fixture symbol is provided, the created fixtures will have the same scope. If a name is provided, they will have scope='function'. Note that in practice the performance loss resulting from using <code>function</code> rather than a higher scope is negligible since the created fixtures' body is a one-liner.</li> <li>in_cls: a boolean (default <code>False</code>). You may wish to turn this to <code>True</code> to use this function inside a class. If you do so, you MUST assign the output to variables in the class.</li> <li>hook: an optional hook to apply to each fixture function that is created during this call. The hook function will be called every time a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use <code>saved_fixture</code> from <code>pytest-harvest</code> as a hook in order to save all such created fixtures in the fixture store.</li> </ul> <p>Outputs: the created fixtures.</p>"},{"location":"api_reference/#fixture_union","title":"<code>fixture_union</code>","text":"<pre><code>def fixture_union(name: str,\n                  fixtures: Iterable[Union[str, Callable]],\n                  scope: str = \"function\",\n                  idstyle: Optional[str] = 'compact',\n                  ids: Union[Callable, Iterable[str]] = None,\n                  unpack_into: Iterable[str] = None,\n                  autouse: bool = False,\n                  hook: Callable = None,\n                  **kwargs) -&gt; &lt;Fixture&gt;\n</code></pre> <p>Creates a fixture that will take all values of the provided fixtures in order. That fixture is automatically registered into the callers' module, but you may wish to assign it to a variable for convenience. In that case make sure that you use the same name, e.g. <code>a = fixture_union('a', ['b', 'c'])</code></p> <p>The style of test ids corresponding to the union alternatives can be changed with <code>idstyle</code>. Three values are allowed:</p> <ul> <li><code>'explicit'</code> favors readability with names as <code>&lt;union&gt;/&lt;alternative&gt;</code>,</li> <li><code>'compact'</code> (default) adds a small mark so that at least one sees which parameters are union alternatives and      which others are normal parameters: <code>/&lt;alternative&gt;</code></li> <li><code>None</code> or <code>'nostyle'</code> provides minimalistic ids : <code>&lt;alternative&gt;</code> </li> </ul> <p>See <code>UnionIdMakers</code> class for details.</p> <p>You can also pass a callable <code>idstyle</code> that will receive instances of <code>UnionFixtureAlternative</code>. For example <code>str</code>  leads to very explicit ids: <code>&lt;union&gt;/&lt;idx&gt;/&lt;alternative&gt;</code>. See <code>UnionFixtureAlternative</code> class for details.</p> <p>Parameters:</p> <ul> <li><code>name</code>: the name of the fixture to create</li> <li><code>fixtures</code>: an array-like containing fixture names and/or fixture symbols</li> <li><code>scope</code>: the scope of the union. Since the union depends on the sub-fixtures, it should be smaller than the smallest scope of fixtures referenced.</li> <li><code>idstyle</code>: The style of test ids corresponding to the union alternatives. One of <code>'explicit'</code>, <code>'compact'</code>,<code>'nostyle'</code>/<code>None</code>, or a callable (e.g. <code>str</code>) that will receive instances of <code>UnionFixtureAlternative</code>.</li> <li><code>unpack_into</code>: an optional iterable of names, or string containing coma-separated names, for additional fixtures to create to represent parts of this fixture. See <code>unpack_fixture</code> for details.</li> <li><code>ids</code>: as in pytest. The default value returns the correct fixture</li> <li><code>autouse</code>: as in pytest</li> <li><code>hook</code>: an optional hook to apply to each fixture function that is created during this call. The hook function will be called every time a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use <code>saved_fixture</code> from <code>pytest-harvest</code> as a hook in order to save all such created fixtures in the fixture store.</li> <li><code>kwargs</code>: other pytest fixture options. They might not be supported correctly.</li> </ul> <p>Outputs: the new fixture. Note: you do not need to capture that output in a symbol, since the fixture is automatically registered in your module. However if you decide to do so make sure that you use the same name.</p>"},{"location":"api_reference/#param_fixtures","title":"<code>param_fixtures</code>","text":"<pre><code>def param_fixtures(argnames: str,\n                   argvalues: Iterable[Any],\n                   autouse: bool = False,\n                   ids: Union[Callable, Iterable[str]] = None, \n                   scope: str = \"function\",\n                   hook: Callable = None,\n                   debug: bool = False,\n                   **kwargs) -&gt; Tuple[&lt;Fixture&gt;]\n</code></pre> <p>Creates one or several \"parameters\" fixtures - depending on the number or coma-separated names in <code>argnames</code>. The created fixtures are automatically registered into the callers' module, but you may wish to assign them to variables for convenience. In that case make sure that you use the same names, e.g. <code>p, q = param_fixtures('p,q', [(0, 1), (2, 3)])</code>.</p> <p>Note that the <code>(argnames, argvalues, ids)</code> signature is similar to <code>@pytest.mark.parametrize</code> for consistency, see pytest doc on parametrize.</p> <pre><code>import pytest\nfrom pytest_cases import param_fixtures, param_fixture\n\n# create a 2-tuple parameter fixture\narg1, arg2 = param_fixtures(\"arg1, arg2\", [(1, 2), (3, 4)])\n\n@pytest.fixture\ndef fixture_uses_param2(arg2):\n    ...\n\ndef test_uses_param2(arg1, arg2, fixture_uses_param2):\n    ...\n</code></pre> <p>Parameters:</p> <ul> <li><code>argnames</code>: same as <code>@pytest.mark.parametrize</code> <code>argnames</code>.</li> <li><code>argvalues</code>: same as <code>@pytest.mark.parametrize</code> <code>argvalues</code>.</li> <li><code>autouse</code>: see fixture <code>autouse</code></li> <li><code>ids</code>: same as <code>@pytest.mark.parametrize</code> <code>ids</code></li> <li><code>scope</code>: see fixture <code>scope</code> </li> <li><code>hook</code>: an optional hook to apply to each fixture function that is created during this call. The hook function will be called every time a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use <code>saved_fixture</code> from <code>pytest-harvest</code> as a hook in order to save all such created fixtures in the fixture store.</li> <li><code>kwargs</code>: any other argument for the created 'fixtures'</li> </ul>"},{"location":"api_reference/#param_fixture","title":"<code>param_fixture</code>","text":"<pre><code>param_fixture(argname, argvalues, \n              autouse=False, ids=None, hook=None, scope=\"function\", **kwargs)\n              -&gt; &lt;Fixture&gt;\n</code></pre> <p>Identical to <code>param_fixtures</code> but for a single parameter name, so that you can assign its output to a single variable.</p>"},{"location":"api_reference/#parametrize","title":"<code>@parametrize</code>","text":"<pre><code>def parametrize(argnames: str=None,\n                argvalues: Iterable[Any]=None,\n                indirect: bool = False,\n                ids: Union[Callable, Iterable[str]] = None,\n                idstyle: Union[str, Callable] = None,\n                idgen: Union[str, Callable] = _IDGEN,\n                auto_refs: bool = True,\n                scope: str = None,\n                hook: Callable = None,\n                scope: str = \"function\",\n                debug: bool = False,\n                **args)\n</code></pre> <p>Equivalent to <code>@pytest.mark.parametrize</code> but also supports </p> <p>New alternate style for argnames/argvalues. One can also use <code>**args</code> to pass additional <code>{argnames: argvalues}</code> in the same parametrization call. This can be handy in combination with <code>idgen</code> to master the whole id template associated with several parameters. Note that you can pass coma-separated argnames too, by de-referencing a dict: e.g. <code>**{'a,b': [(0, True), (1, False)], 'c': [-1, 2]}</code>.</p> <p>New alternate style for ids. One can use <code>idgen</code> instead of <code>ids</code>. <code>idgen</code> can be a callable receiving all parameters at once (<code>**args</code>) and returning an id ; or it can be a string template using the new-style string formatting where the argnames can be used as variables (e.g. <code>idgen=lambda **args: \"a={a}\".format(**args)</code> or <code>idgen=\"my_id where a={a}\"</code>). The special <code>idgen=AUTO</code> symbol can be used to generate a default string template equivalent to <code>lambda **args: \"-\".join(\"%s=%s\" % (n, v) for n, v in args.items())</code>. This is enabled by default if you use the alternate style for argnames/argvalues (e.g. if <code>len(args) &gt; 0</code>), and if there are no <code>fixture_ref</code>s in your argvalues.</p> <p>New possibilities in argvalues:</p> <ul> <li> <p>one can include references to fixtures with <code>fixture_ref(&lt;fixture&gt;)</code> where  can be the fixture name or fixture function. When such a fixture reference is detected in the argvalues, a new function-scope \"union\" fixture will be created with a unique name, and the test function will be wrapped so as to be injected with the correct parameters from this fixture. Special test ids will be created to illustrate the switching between the various normal parameters and fixtures. You can see debug print messages about all fixtures created using <code>debug=True</code>. New: from version <code>3.2</code> on, if <code>auto_refs=True</code> (default), <code>@parametrize</code> will automatically detect fixture symbols in the list of argvalues, and will create <code>fixture_ref</code>s automatically around them so that you don't need to. <li> <p>one can include lazy argvalues with <code>lazy_value(&lt;valuegetter&gt;, [id=..., marks=...])</code>. A <code>lazy_value</code> is the same thing than a function-scoped fixture, except that the value getter function is not a fixture and therefore can neither be parametrized nor depend on fixtures. It should have no mandatory argument.</p> </li> <p>Both <code>fixture_ref</code> and <code>lazy_value</code> can be used to represent a single argvalue, or a whole tuple of argvalues when there are several argnames. Several of them can be used in a tuple.</p> <p>Finally, <code>pytest.param</code> is supported even when there are <code>fixture_ref</code> and <code>lazy_value</code>. </p> <p>Here as for all functions above, an optional <code>hook</code> can be passed, to apply on each fixture function that is created during this call. The hook function will be called every time a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use <code>saved_fixture</code> from <code>pytest-harvest</code> as a hook in order to save all such created fixtures in the fixture store.</p> <p>Parameters</p> <ul> <li> <p><code>argnames</code>: same than in <code>@pytest.mark.parametrize</code></p> </li> <li> <p><code>argvalues: same as in pytest.mark.parametrize except that</code>fixture_ref<code>and</code>lazy_value` are supported</p> </li> <li> <p><code>indirect</code>: same as in pytest.mark.parametrize. Note that it is not recommended and is not guaranteed to work in complex parametrization scenarii.</p> </li> <li> <p><code>ids</code>: same as in pytest.mark.parametrize. Note that an alternative way to create ids exists with <code>idgen</code>. Only one non-None <code>ids</code> or <code>idgen</code> should be provided.</p> </li> <li> <p><code>idgen</code>: an id formatter. Either a string representing a template, or a callable receiving all argvalues at once (as opposed to the behaviour in pytest ids). This alternative way to generate ids can only be used when <code>ids</code> is not provided (None). You can use the special <code>pytest_cases.AUTO</code> formatter to generate an automatic id with template <code>&lt;name&gt;=&lt;value&gt;-&lt;name2&gt;=&lt;value2&gt;-...</code>. <code>AUTO</code> is enabled by default if you use the alternate style for argnames/argvalues (e.g. if <code>len(args) &gt; 0</code>), and if there are no <code>fixture_ref</code>s in your argvalues.</p> </li> <li> <p><code>idstyle</code>: This is mostly for debug. Style of ids to be used in the \"union\" fixtures generated by <code>@parametrize</code> if at least one <code>fixture_ref</code> is found in the argvalues. <code>idstyle</code> possible values are 'compact', 'explicit' or None/'nostyle' (default), or a callable. <code>idstyle</code> has no effect if no <code>fixture_ref</code> are present in the argvalues. As opposed to <code>ids</code>, a callable provided here will receive a <code>ParamAlternative</code> object indicating which generated fixture should be used.</p> </li> <li> <p><code>auto_refs</code>: a boolean. If this is <code>True</code> (default), argvalues containing fixture symbols will automatically be wrapped into a <code>fixture_ref</code>, for convenience.</p> </li> <li> <p><code>scope</code>: The scope of the union fixture to create if <code>fixture_ref</code>s are found in the argvalues. Otherwise same as in <code>pytest.mark.parametrize</code>.</p> </li> <li> <p><code>hook</code>: an optional hook to apply to each fixture function that is created during this call. The hook function will be called every time a fixture is about to be created. It will receive a single argument (the function implementing the fixture) and should return the function to use. For example you can use <code>saved_fixture</code> from <code>pytest-harvest</code> as a hook in order to save all such created fixtures in the fixture store.</p> </li> <li> <p><code>debug</code>: print debug messages on stdout to analyze fixture creation (use pytest -s to see them)</p> </li> </ul>"},{"location":"api_reference/#lazy_value","title":"<code>lazy_value</code>","text":"<pre><code>def lazy_value(valuegetter: Callable[[], Any],\n               id: str = None,\n               marks: Union[Any, Sequence[Any]] = ()\n               ) -&gt; LazyValue\n</code></pre> <p>A reference to a value getter (an argvalue-providing callable), to be used in <code>@parametrize</code>.</p> <p>A <code>lazy_value</code> is the same thing than a function-scoped fixture, except that the value getter function is not a fixture and therefore can neither be parametrized nor depend on fixtures. It should have no mandatory argument. The underlying function will be called exactly once per test node.</p> <p>By default the associated id is the name of the <code>valuegetter</code> callable, but a specific <code>id</code> can be provided otherwise. Note that this <code>id</code> does not take precedence over custom <code>ids</code> or <code>idgen</code> passed to <code>@parametrize</code>.</p> <p>Note that a <code>lazy_value</code> can be included in a <code>pytest.param</code> without problem. In that case the id defined by <code>pytest.param</code> will take precedence over the one defined in <code>lazy_value</code> if any. The marks, however, will all be kept wherever they are defined.</p> <p>Parameters</p> <ul> <li><code>valuegetter</code>: a callable without mandatory arguments</li> <li><code>id</code>: an optional id. Otherwise <code>valuegetter.__name__</code> will be used by default</li> <li><code>marks</code>: optional marks. <code>valuegetter</code> marks will also be preserved.</li> </ul>"},{"location":"api_reference/#is_lazy","title":"<code>is_lazy</code>","text":"<pre><code>def is_lazy(argval) -&gt; bool\n</code></pre> <p>Return <code>True</code> if <code>argval</code> is the outcome of processing a <code>lazy_value</code> through <code>@parametrize</code>. This encompasses parameters that are items of lazy tuples that are created when parametrizing several argnames with the same <code>lazy_value()</code>.</p>"},{"location":"api_reference/#fixture_ref","title":"<code>fixture_ref</code>","text":"<pre><code>def fixture_ref(fixture: Union[str, Fixture]\n                )\n</code></pre> <p>A reference to a fixture to be used with <code>@parametrize</code>. Create it with <code>fixture_ref(&lt;fixture&gt;)</code> where  can be the fixture name or actual fixture function."},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#380-async-generators-and-strict-markers","title":"3.8.0 - async, generators and strict-markers","text":"<ul> <li><code>@fixture</code> and <code>@parametrize</code> are now async and generator aware. Fixes    #286. PR    #301 by jgersti.</li> <li>Fixed error with <code>pytest</code> <code>--strict-markers</code>. Fixes    #283. PR    #300 by chrsmcgrr.</li> </ul>"},{"location":"changelog/#370-python-312","title":"3.7.0 - python 3.12","text":"<ul> <li>Added official support for Python 3.10, 3.11 and 3.12. Fixes #314</li> <li>Fixed <code>ModuleNotFoundError: distutils</code> on Python 3.12 thanks to <code>packaging</code>. PR    #312 by @jayqi. </li> <li>Internal: switched to virtualenv backend.</li> </ul>"},{"location":"changelog/#3614-bugfixes","title":"3.6.14 - bugfixes","text":"<ul> <li>Fixed <code>AttributeError</code> issue in <code>is_case_function</code> when an inspected symbol is a parametrized type hint    without <code>__name__</code>. Fixes #287</li> <li>Fixed issue with <code>get_all_cases</code>: default value for <code>cases</code> was wrong. Fixes #290</li> </ul>"},{"location":"changelog/#3613-bugfix","title":"3.6.13 - bugfix","text":"<ul> <li>Fixed issue where a lazy value (for example a case function) was not resolved before being injected in a parametrized function, and was therefore appearing as a <code>_LazyValueCaseParamValue</code>. Fixed #274</li> </ul>"},{"location":"changelog/#3612-type-hint-fix-enhanced-compatibility-with-pytest-plugins","title":"3.6.12 - type hint fix + enhanced compatibility with pytest plugins","text":"<ul> <li>Improved compatibility with other <code>pytest</code> plugins, in particular <code>pytest-repeat</code>, by supporting removal from fixture closure tree. Fixed #269.</li> <li>Fixed type hint errors detected by <code>pyright</code>. Fixed #270</li> </ul>"},{"location":"changelog/#3611-bugfix-for-pytest-xdist-and-get_all_cases-api-improvement","title":"3.6.11 - bugfix for pytest-xdist and <code>get_all_cases</code> API improvement","text":"<ul> <li><code>get_all_cases</code> can now be called without <code>parametrization_target</code> (defaulting to the caller module), and with an explicit module object. Fixed #258. PR #260 by @eddiebergman.</li> <li>Fixed <code>AttributeError</code>: module 'pytest_cases' has no attribute 'CasesCollectionWarning' when running <code>pytest-xdist</code> and at least one cases class is ignored because of <code>__init__</code> or <code>__new__</code>. Fixed #249.</li> </ul>"},{"location":"changelog/#3610-bugfix-for-pytest-71","title":"3.6.10 - bugfix for pytest 7.1","text":"<ul> <li>Fixed <code>ImportError</code> when using <code>pytest 7.1</code>. Fixed #264 and pytest-dev#9762.</li> </ul>"},{"location":"changelog/#369-bugfix-with-pytest-7","title":"3.6.9 - Bugfix with pytest 7","text":"<ul> <li>Fixed <code>FrozenInstanceError</code> when using <code>pytest 7.0.0</code>. Fixed #251. PR#253 by jammer87</li> </ul>"},{"location":"changelog/#368-bugfix-support-for-multiprocessing-pool","title":"3.6.8 - Bugfix: support for multiprocessing Pool","text":"<ul> <li>Suppressed warnings in our own tests, to improve packaging maintenance. Fixed #248</li> <li>Fixed bug where setting <code>ids</code> in <code>@parametrize</code> without setting explicitly <code>idgen=None</code> would raise a <code>ValueError</code>. Fixed #238.</li> <li>Fixed bug where case-holding class marks were not propagated to static methods and class methods. Fixed #246 </li> <li>Fixed support for multiprocessing <code>Pool</code>. Fixes #242</li> </ul>"},{"location":"changelog/#367-minor-improvements-and-preparing-for-pytest-7","title":"3.6.7 - Minor improvements and preparing for pytest 7","text":"<ul> <li>Improved error message when a case function nested in a class has no <code>self</code> argument and is not static. Fixes #243</li> <li>Added support for the new Scopes enum in pytest 7. Fixed #241</li> <li>Fixed <code>__version__</code> in development mode.</li> </ul>"},{"location":"changelog/#366-layout-change","title":"3.6.6 - Layout change","text":"<ul> <li>Restructured project so that tests are truly independent, to ease rpm/apt/etc. packaging. Fixed #220.</li> </ul>"},{"location":"changelog/#365-bugfix","title":"3.6.5 - Bugfix","text":"<ul> <li>Fixed an issue where using keyword <code>argnames</code> in <code>@pytest.mark.parametrize</code> would cause <code>IndexError: tuple index out of range</code> in the tests collection phase. Fixed #234.</li> </ul>"},{"location":"changelog/#364-bugfix","title":"3.6.4 - Bugfix","text":"<ul> <li>A case id can now be a reserved keyword without triggering any <code>SyntaxError</code>, even if the case is transformed into a fixture. Fixes #230</li> </ul>"},{"location":"changelog/#363-bugfix","title":"3.6.3 - Bugfix","text":"<ul> <li>Fixed an issue where a lazy value would not be resolved. This happens when the \"auto-simplify fixture\" happens in <code>@parametrize</code>. Fixes #225</li> </ul>"},{"location":"changelog/#362-qualimetry","title":"3.6.2 - Qualimetry","text":"<ul> <li>Fixed most <code>flake8</code> errors and updated documentation to use <code>genbadge</code>. Fixes #223</li> </ul>"},{"location":"changelog/#361-bugfix-parametrizing-a-class-with-parametrize","title":"3.6.1 - bugfix - parametrizing a class with <code>@parametrize</code>","text":"<ul> <li>Fixed <code>ValueError</code> when <code>@parametrize</code> is used to parametrize a class. Also, added a more explicit <code>TypeError</code> when <code>@parametrize</code> is used to parametrize a class and at least a fixture reference is present. Fixed #215.</li> </ul>"},{"location":"changelog/#360-unpack_fixtures-in-classes-current_cases-improvements","title":"3.6.0 - <code>unpack_fixtures</code> in classes + <code>current_cases</code> improvements","text":"<ul> <li> <p>The <code>current_cases</code> fixture now contains case parameters if any. Fixes #214</p> </li> <li> <p>The <code>current_cases</code> fixture entries are now instances of <code>namedtuple</code>.</p> </li> <li> <p>New <code>in_cls</code> argument in <code>unpack_fixtures</code> so that it can be used inside classes. Fixes #201</p> </li> <li> <p>Fixed minor issue where empty entries could be present in <code>currentcases</code>. Fixes #213</p> </li> </ul>"},{"location":"changelog/#352-bugfix-with-the-currentcases-fixture","title":"3.5.2 - bugfix with the <code>currentcases</code> fixture","text":"<ul> <li>Fixed issues where the <code>currentcases</code> fixture would not return the correct case function. Fixed #212</li> </ul>"},{"location":"changelog/#351-python-310-compatibility-improved-error-message","title":"3.5.1 - python 3.10 compatibility + improved error message","text":"<ul> <li>Fixed error message related to misuse of <code>fixture_ref</code>. Fixes #209</li> <li>Fixed import error with python 3.10. Fixes #207</li> </ul>"},{"location":"changelog/#350-new-current_cases-fixture-and-get_current_cases-function-fixes","title":"3.5.0 - New <code>current_cases</code> fixture and <code>get_current_cases</code> function + Fixes","text":"<ul> <li> <p>New: Users can now easily access the current cases for each parametrized argument thanks to the new <code>current_cases</code> fixture. A new helper function <code>get_current_cases</code> is also provided, for direct access from a hook. <code>get_current_case_id</code> becomes deprecated in favour of these two. Fixes #195</p> </li> <li> <p>Bugfix: Fixed issue where the cache of a <code>lazy_value</code> used for a tuple of parameters (several <code>argnames</code>) was not considering the pytest context and thus was wrongly used across pytest nodes. Fixes #202</p> </li> <li> <p>Improved error message when a fixture parametrized with several argnames as once is not able to unpack the parameter values received (non subscriptable object).</p> </li> <li> <p><code>parametrize_plus</code> and <code>fixture_plus</code> are now deprecated in favour of <code>parametrize</code> and <code>fixture</code>, as most users seem to have adopted these names without issues.</p> </li> <li> <p>(internal) Replaced the <code>\"used\"</code> parameter with a dedicated singleton <code>USED</code></p> </li> </ul>"},{"location":"changelog/#346-increased-compatibility-with-other-plugins","title":"3.4.6 - Increased compatibility with other plugins","text":"<ul> <li><code>LazyValue</code>, <code>LazyTuple</code> and <code>LazyTupleItem</code> are now hashable. This increases compatibility with plugins hashing the parameter values, such as pytest-steps. See pytest-steps#41 . Fixes #199</li> </ul>"},{"location":"changelog/#345-bugfix","title":"3.4.5 - Bugfix","text":"<ul> <li>Fixed bug when a test module containing <code>@parametrize_with_cases</code> was executed outside of <code>pytest</code>, typically through its <code>__main__</code>. Fixes #198</li> </ul>"},{"location":"changelog/#344-bugfix","title":"3.4.4 - Bugfix","text":"<ul> <li>Fixed issue when <code>@parametrize_with_cases</code> was used on a fixture in a <code>conftest.py</code>. Fixes #196</li> </ul>"},{"location":"changelog/#343-technical-release-zenodo","title":"3.4.3 - Technical release - Zenodo","text":"<p>Technical release to check that Zenodo metadata is now preserved. Same as 3.4.2, 3.4.1 and 3.4.0.</p>"},{"location":"changelog/#340-goodbye-v1-api-support-for-unbound-cases-bugfix-with-marks-fixtures-in-case-files","title":"3.4.0 - Goodbye v1 API + Support for unbound cases + Bugfix with marks + Fixtures in case files","text":"<ul> <li> <p>Legacy v1 API was dropped. Fixes #192</p> </li> <li> <p>Unbound case functions in a class (e.g. <code>Foo.bar</code>) can now be directly passed to <code>parametrize_with_cases</code> without instantiating the class, e.g. <code>parametrize_with_cases(cases=Foo.bar)</code>. Fixes #159</p> </li> <li> <p>Fixed bug with concatenation of marks on cases. Fixes #191</p> </li> <li> <p>Fixed an issue where a case transformed into a fixture, with the same name as the fixture it requires, would lead to a <code>pytest</code> fixture recursion. </p> </li> <li> <p>Fixtures in case files can now be automatically imported using the experimental <code>@parametrize_with_cases(import_fixtures=True)</code>. Fixes #193</p> </li> </ul>"},{"location":"changelog/#330-filter-helpers-current-id-getter-support-for-pytest-asyncio-and-other-plugins","title":"3.3.0 - Filter helpers, Current id getter, Support for <code>pytest-asyncio</code> and other plugins","text":"<ul> <li> <p>Migrated to Github Actions + <code>nox</code> for CI/CD.</p> </li> <li> <p>New helper function <code>get_current_case_id</code> to get the current case id for a given <code>pytest</code> request or item. Fixes #189</p> </li> <li> <p>Extended the support of fixture closure modifications to <code>remove</code> and <code>insert(0, f)</code>. This in particular solves an issue with <code>pytest-asyncio</code>. Fixes #176</p> </li> <li> <p>New <code>filters</code> module providing helper functions <code>has_tag</code>, <code>id_has_prefix</code>, <code>id_has_suffix</code>, <code>id_match_regex</code> to easily create custom filters for use in <code>@parametrize_with_cases(filter=...)</code>. PR #184 by @saroad2, (thanks !).</p> </li> </ul>"},{"location":"changelog/#321-fixture-bugfix","title":"3.2.1 - <code>@fixture</code> Bugfix","text":"<ul> <li>Fixed <code>fixture 'self' not found</code> issue when <code>@fixture</code> was used to decorate a class method not explicitly depending on <code>request</code>. Fixed #182</li> </ul>"},{"location":"changelog/#320-automatic-fixture_ref-test-ordering-bugfix","title":"3.2.0 - Automatic <code>fixture_ref</code> + test ordering bugfix","text":"<ul> <li> <p>New: from version <code>3.2</code> on, if <code>auto_refs=True</code> (default), <code>@parametrize</code> will automatically detect fixture symbols in the list of argvalues, and will create <code>fixture_ref</code>s automatically around them so that you don't need to. Fixes #177</p> </li> <li> <p>Fixed ordering issue happening on linux targets when several <code>@parametrize</code> are used to decorate the same function. Fixes #180</p> </li> </ul>"},{"location":"changelog/#312-bugfixes-with-nesting-and-pytest-asyncio","title":"3.1.2 - Bugfixes with nesting and pytest-asyncio","text":"<ul> <li> <p>Now appending fixtures to the closure once it has been built is supported. This fixes an issue with <code>pytest-asyncio</code>. Fixes #176</p> </li> <li> <p>Fixed issue when <code>parametrize_with_cases</code> was used on case functions themselves (nesting/recursion). This was due to a lack of support of the <code>place_as</code> magic pytest attribute. Fixes #179</p> </li> <li> <p>Added a warning concerning usage of indirect in parametrize when fixture references are present. See #150</p> </li> </ul>"},{"location":"changelog/#311-bugfix-with-ids","title":"3.1.1 - Bugfix with ids","text":"<ul> <li>Fixed issue with Empty id marker leaking to test ids. Fixed #171</li> </ul>"},{"location":"changelog/#310-improved-cases-collection","title":"3.1.0 - Improved cases collection","text":"<ul> <li> <p><code>@parametrize_with_cases</code> now by default (<code>cases=AUTO</code>) looks for both file naming patterns <code>test_&lt;name&gt;_cases.py</code> and <code>cases_&lt;name&gt;.py</code>. Removed the <code>AUTO2</code> constant. Fixed #140</p> </li> <li> <p>Nested classes containing case functions are now officially supported (they were, but undocumented). Fixed #160</p> </li> <li> <p>Case functions that are <code>staticmethod</code> and <code>classmethod</code> are now supported as well. Fixes #168</p> </li> </ul>"},{"location":"changelog/#300-harmonization-of-ids-and-public-api-for-cases-info","title":"3.0.0 - harmonization of ids and public API for cases info","text":"<ul> <li> <p>Major refactoring of the way ids and marks are generated and customized in <code>fixture_union</code>, <code>@parametrize</code> and <code>@parametrize_with_cases</code>. Now <code>idstyle</code> has a consistent behaviour across the board, <code>ids</code> and <code>idstyle</code> can work together correctly, <code>@parametrize_with_cases</code> and <code>@parametrize</code> have much better default values for ids, and many others. See documentation for details. Fixed #154</p> </li> <li> <p>New public API to manipulate information about a case function: <code>copy_case_info</code>, <code>set_case_id</code>, <code>get_case_id</code>, <code>get_case_marks</code>, <code>get_case_tags</code>, <code>matches_tag_query</code>, <code>is_case_class</code>, <code>is_case_function</code>. See API reference.</p> </li> <li> <p>Fixed default behaviour of <code>idgen</code> in <code>@parametrize</code>: it only defaults to <code>AUTO</code> when no <code>fixture_ref</code> are used in the argvalues.</p> </li> </ul>"},{"location":"changelog/#272-bugfix-with-doctest","title":"2.7.2 - Bugfix with doctest","text":"<ul> <li>Fixed <code>AttributeError: 'DoctestItem' object has no attribute '_request'</code> when executing doctests. Fixes #156</li> </ul>"},{"location":"changelog/#271-pytestmarkusefixtures-can-be-used-on-case-functions","title":"2.7.1 - <code>@pytest.mark.usefixtures</code> can be used on case functions","text":"<ul> <li><code>@pytest.mark.usefixtures</code> can be now be used on case functions. Fixes #152.</li> </ul>"},{"location":"changelog/#270-parametrize_with_cases-now-supports-id-customization","title":"2.7.0 - <code>@parametrize_with_cases</code> now supports id customization","text":"<ul> <li><code>@parametrize_with_cases</code> now explicitly supports all id customization methods (<code>ids</code>, <code>idgen</code> and <code>idstyle</code>) supported by <code>@parametrize</code> (<code>ids</code>, <code>idgen</code> and <code>idstyle</code>). Updated documentation accordingly. Fixed #151</li> </ul>"},{"location":"changelog/#260-better-cache-for-lazy-values-and-support-for-infinite-id-generators","title":"2.6.0 - better cache for lazy values and support for infinite id generators","text":"<ul> <li> <p><code>lazy_value</code> parameters are now cached by pytest node id only. So plugins can access the value without triggering an extra function call, but a new call is triggered for each pytest node, so as to prevent mutable object leakage across tests. Fixed #149 while ensuring no regression for #143.</p> </li> <li> <p>The <code>ids</code> argument of <code>parametrize</code> now accepts a (possibly infinite) generator of ids, e.g. (<code>f\"foo{i}\" for i in itertools.count()</code>), just as <code>pytest</code> does. This was not always the case, inparticular when parametrizing a <code>@fixture</code>. The <code>ids</code> arguments of <code>fixture_union</code>, <code>param_fixture[s]</code>, etc. now also support this pattern. Fixed #148</p> </li> </ul>"},{"location":"changelog/#250-case-ids-glob-match-improvements","title":"2.5.0 - case ids <code>glob</code> match improvements","text":"<ul> <li>Improved description for the <code>glob</code> argument in <code>@parametrize_with_cases</code>. Also made the implementation escape all regex special characters so that they can't be used. Finally a pattern should now match the entire case id (previously, a partial match would work if it was at the beginning of the string). One step towards #147</li> </ul>"},{"location":"changelog/#240-various-fixes-for-test-ids-and-lazy-values","title":"2.4.0 - various fixes for test ids and lazy values","text":"<ul> <li> <p><code>is_lazy</code> is now part of public API, and <code>_LazyValue</code> now has a cache mechanism like <code>_LazyTuple</code>. Fixes #143</p> </li> <li> <p><code>@parametrize</code>: custom <code>ids</code> are now correctly taken into account when a single <code>lazy_value</code>is used for a tuple of parameters. This issue could be seen also with <code>@parametrize_with_cases</code>: <code>idgen</code> does not seem to be taken into account when cases are unpacked into a tuple. Fixes #144.</p> </li> <li> <p>Empty case ids are now replaced with <code>'&lt;empty_case_id&gt;'</code> to avoid ambiguous interpretation of test ids. Fixes #142.</p> </li> </ul>"},{"location":"changelog/#230-better-lazyvalue-internal-api","title":"2.3.0 - better <code>LazyValue</code> internal API","text":"<ul> <li>new <code>clone(self, remove_int_base=False)</code> API on <code>LazyValue</code> and <code>LazyTupleItem</code> instances. With this new API, on old <code>pytest</code> <code>&lt; 5.3</code>, other plugins such as <code>pytest-harvest</code> can easily clone the contents from lazy values without having them inherit from <code>int</code> - which was a dirty hack used by <code>pytest-cases</code> to trick <code>pytest</code> to generate acceptable test ids in these old pytest versions. Also improved the <code>LazyValue</code>, <code>LazyTuple</code> and <code>LazyTupleItem</code> object model with equality and repr. Fixes pytest-harvest#43</li> </ul>"},{"location":"changelog/#225-marks-are-now-correctly-propagated-from-case-class","title":"2.2.5 - Marks are now correctly propagated from Case class","text":"<ul> <li>Marks set on a case class are now propagated to cases in the class. So you can use for example <code>pytest-pilot</code> more easily ! Fixes #139</li> </ul>"},{"location":"changelog/#224-fixes-issue","title":"2.2.4 - Fixes issue","text":"<ul> <li>Fixed \"Created fixture names are not unique, please report\" error when duplicate fixture reference is provided in a pytest.param. Fixes #138.</li> </ul>"},{"location":"changelog/#223-fixed-issue-with-pytest-3x","title":"2.2.3 - Fixed issue with pytest <code>3.X</code>","text":"<ul> <li>Fixed <code>TypeError: _idval() got an unexpected keyword argument 'item'</code> with <code>pytest</code> versions between 3.0.0 and 3.7.4. Fixed #136</li> </ul>"},{"location":"changelog/#222-parametrize_with_cases-compatibility-improvements","title":"2.2.2 - <code>@parametrize_with_cases</code> compatibility improvements","text":"<ul> <li><code>@parametrize_with_cases</code> now supports that <code>argnames</code> is a list or tuple, just as <code>@pytest.mark.parametrize</code> does. PR #132, by <code>@saroad2</code>.</li> </ul>"},{"location":"changelog/#221-setuppy-fix-to-enforce-dependency-version","title":"2.2.1 - setup.py fix to enforce dependency version","text":"<ul> <li>Now enforcing usage of <code>makefun</code> 1.9.3 or above to avoid issue <code>AttributeError: 'functools.partial' object has no attribute '__module__'</code> mentioned in #128</li> </ul>"},{"location":"changelog/#220-doc-improvements-bugfix-for-cases-requiring-fixtures","title":"2.2.0 - Doc improvements + bugfix for cases requiring fixtures","text":"<ul> <li> <p>Improved documentation to explain why <code>@fixture</code> should be used instead of <code>@pytest.fixture</code>. Fixed #125</p> </li> <li> <p>Fixed <code>ValueError: fixture is being applied more than once to the same function</code> when two functions parametrized with the same cases were sitting in the same file. Improved robustness when cases require fixtures, in particular when parametrized test/fixture sits in a class or when several of them sit in a class/module. Fixed #126</p> </li> </ul>"},{"location":"changelog/#213-missing-deprecation-warning","title":"2.1.3 - Missing deprecation warning","text":"<ul> <li> <p>Added missing deprecation warning on <code>@cases_generator</code>. Fixes #124.</p> </li> <li> <p>Removed <code>target</code> and <code>tags</code> arguments of <code>@cases_generator</code> (deprecated api anyway) that were added by mistake in version 2.0.0 but never used.</p> </li> </ul>"},{"location":"changelog/#212-compatibility-fix","title":"2.1.2 - Compatibility fix","text":"<ul> <li>Added support for pytest items without funcargs. Fixes interoperability with other pytest plugins such as <code>pytest-black</code> or <code>pytest-flake8</code>. Fixes #122</li> </ul>"},{"location":"changelog/#211-fixed-issue-with-pytest-6","title":"2.1.1 - Fixed issue with pytest 6","text":"<p><code>pytest</code> 6 is now supported. Fixes #121 </p>"},{"location":"changelog/#210-internal-engine-improvements-bugfixes","title":"2.1.0 - Internal engine improvements + bugfixes","text":"<p>Fixed issue with <code>@parametrize_with_cases</code> when two cases with the same id and both requiring a fixture were to be created. Fixed #117.</p> <p>Fixture closure engine refactoring:</p> <ul> <li> <p>When no fixture unions are present, the fixture closure is now identical to the default one in <code>pytest</code>, to avoid issues originating from other plugins fiddling with the closure. Fixes #116</p> </li> <li> <p>New <code>SuperClosure</code> class representing the \"list\" facade on top of the fixture tree (instead of <code>FixtureClosureNode</code>). In addition, this list facade now better handles editing the order of fixtures when possible. Fixes #111.</p> </li> <li> <p>Session and Module-scoped fixtures that are not used in all union alternatives are not any more torn town/setup across union alternatives. Fixes #120</p> </li> </ul>"},{"location":"changelog/#204-bugfix","title":"2.0.4 - Bugfix","text":"<ul> <li>Fixed <code>TypeError</code> with iterable argvalue in standard parametrize. Fixed #115.</li> </ul>"},{"location":"changelog/#203-bugfixes","title":"2.0.3 - Bugfixes","text":"<ul> <li> <p>Fixed wrong module string decomposition when passed to <code>cases</code> argument in <code>@parametrize_with_cases</code>. Fixes #113</p> </li> <li> <p>Autouse fixtures are now correctly used. Fixed #114</p> </li> </ul>"},{"location":"changelog/#202-better-string-representation-for-lazy-values","title":"2.0.2 - Better string representation for lazy values","text":"<p>Lazy values (so, test cases) now have a much nicer string representation ; in particular in <code>pytest-harvest</code> results tables. Fixes #112</p>"},{"location":"changelog/#201-better-test-ids-and-theory-page","title":"2.0.1 - Better test ids and theory page","text":"<ul> <li> <p>New documentation page concerning theory of fixture unions. Fixes #109</p> </li> <li> <p>Using a <code>fixture_ref</code> in a new-style <code>@parametrize</code> (with <code>**args</code> or <code>idgen</code>) now outputs a correct id. Fixes #110</p> </li> </ul>"},{"location":"changelog/#200-less-boilerplate-full-pytest-alignment","title":"2.0.0 - Less boilerplate &amp; full <code>pytest</code> alignment","text":"<p>I am very pleased to announce this new version of <code>pytest-cases</code>, providing a lot of major improvements. Creating powerful and complex test suites have never been so easy and intuitive !</p> <p>Below is a complete list of changes, but the user guide has also been updated accordingly so feel free to have a look to get a complete example-based walkthrough.</p> <p>A/ More powerful and flexible cases collection</p> <p>New <code>@parametrize_with_cases</code> decorator to replace <code>@cases_data</code> (deprecated).</p> <ol> <li> <p>Aligned with <code>pytest</code>: </p> <ul> <li> <p>now <code>argnames</code> can contain several names, and the case functions are automatically unpacked into it. You don't need to perform a <code>case.get()</code> in the test anymore !</p> <pre><code>@parametrize_with_cases(\"a,b\")\ndef test_foo(a, b):\n    # use a and b directly !\n    ...\n</code></pre> </li> <li> <p>cases are unpacked at test setup time, so the clock does not run while the case is created - in case you use <code>pytest-harvest</code> to collect the timings.</p> </li> <li> <p><code>@parametrize_with_cases</code> can be used on test functions as well as fixture functions (it was already the case in v1)</p> </li> </ul> </li> <li> <p>Easier to configure: </p> <ul> <li> <p>the decorator now has a single <code>cases</code> argument to indicate the cases, wherever they come from (no <code>module</code> argument anymore)</p> </li> <li> <p>default (<code>cases=AUTO</code>) automatically looks for cases in the associated case module named <code>test_xxx_cases.py</code>. Users can easily switch to alternate pattern <code>cases_xxx.py</code> with <code>cases=AUTO2</code>. Fixes #91.</p> </li> <li> <p>cases can sit inside a class, like what you're used to do with <code>pytest</code>. This additional style makes it much more convenient to organize cases and associated them with tests, when cases sit in the same file than the tests. Fixes #93.</p> </li> <li> <p>an explicit sequence can be provided, it can mix all kind of sources: functions, classes, modules, and module names as strings (even relative ones!).</p> <pre><code>@parametrize_with_cases(\"a\", cases=(CasesClass, '.my_extra_cases'))\ndef test_foo(a):\n    ...\n</code></pre> </li> </ul> </li> <li> <p>More powerful API for filtering:</p> <ul> <li> <p>a new <code>prefix</code> argument (default <code>case_</code>) can be used to define case functions for various type of parameters: welcome <code>user_&lt;id&gt;</code>, <code>data_&lt;id&gt;</code>, <code>algo_&lt;id&gt;</code>, <code>model_&lt;id&gt;</code> ! Fixes #108</p> </li> <li> <p>a new <code>glob</code> argument receiving a glob-like string can be used to further filter cases based on their names. For example you can distinguish <code>*_success</code> from <code>*_failure</code> case ids, so as to dispatch them to the appropriate positive or negative test. Fixes #108</p> </li> <li> <p>finally you can still use <code>has_tag</code> and/or provide a <code>filter</code> callable, but now the callable will receive the case function, and this case function has a <code>f._pytestcase</code> attribute containing the id, tags and marks - it is therefore much easier to implement custom filtering.</p> </li> </ul> </li> </ol> <p>B/ Easier-to-define case functions</p> <ul> <li> <p>Case functions can start with different prefixes to denote different kind of data: e.g. <code>data_&lt;id&gt;</code>, <code>user_&lt;id&gt;</code>, <code>model_&lt;id&gt;</code>, etc.</p> </li> <li> <p>Case functions can now be parametrized with <code>@parametrize</code> or <code>@pytest.mark.parametrize</code>, just as in pytest ! This includes the ability to put <code>pytest</code> marks on the whole case, or on some specific parameter values using <code>pytest.param</code>. <code>@cases_generator</code> is therefore now deprecated but its alternate style for ids and arguments definition was preserved in <code>@parametrize</code>, see below. </p> </li> <li> <p>Now case functions can require fixtures ! In that case they will be transformed into fixtures and injected as <code>fixture_ref</code> in the parametrization. Fixes #56.</p> </li> <li> <p>New single optional <code>@case(id=None, tags=(), marks=())</code> decorator to replace <code>@case_name</code> and <code>@case_tags</code> (deprecated): a single simple way to customize all aspects of a case function. Also, <code>@test_target</code> completely disappears from the picture as it was just a tag like others - this could be misleading.</p> </li> </ul> <p>C/ Misc / pytest goodies</p> <ul> <li> <p>New aliases for readability: <code>@fixture</code> for <code>@fixture_plus</code>, and<code>@parametrize</code> for <code>@parametrize_plus</code> (both aliases will coexist with the old names). Fixes #107.</p> </li> <li> <p><code>@parametrize</code> was improved in order to support the alternate parametrization mode that was previously offered by <code>@cases_generator</code>, see api reference. That way, users will be able to choose the style of their choice. Fixes #57 and #106.</p> </li> <li> <p><code>@parametrize</code> now raises an explicit error message when the user makes a mistake with the argnames. Fixes #105.</p> </li> <li> <p>More readable error messages in <code>@parametrize</code> when <code>lazy_value</code> does not return the same number of argvalues than expected from the argnames.</p> </li> <li> <p>Any error message associated to a <code>lazy_value</code> function call is not caught and hidden anymore but is emitted to the user, for easier debugging.</p> </li> <li> <p>Fixed issue with <code>lazy_value</code> when a single mark is passed in the constructor.</p> </li> <li> <p><code>lazy_value</code> used as a tuple for several arguments now have a correct id generated even in old pytest version 2.</p> </li> <li> <p>New pytest goodie <code>assert_exception</code> that can be used as a context manager. Fixes #104.</p> </li> </ul>"},{"location":"changelog/#1170-lazy_value-improvements-annoying-warnings-suppression","title":"1.17.0 - <code>lazy_value</code> improvements + annoying warnings suppression","text":"<ul> <li> <p><code>lazy_value</code> are now resolved at pytest <code>setup</code> stage, not pytest <code>call</code> stage. This is important for execution time recorded in the reports (see also <code>pytest-harvest</code> plugin). Fixes #102 </p> </li> <li> <p>A function used as a <code>lazy_value</code> can now be marked with pytest marks. Fixes #99</p> </li> <li> <p>A <code>lazy_value</code> now has a nicer id when it is a partial. Fixes #97</p> </li> <li> <p>Removed annoying <code>PytestUnknownMarkWarning</code> warning message when a mark was used on a case. Fixes #100</p> </li> </ul>"},{"location":"changelog/#1160-new-lazy_value-for-parameters","title":"1.16.0 - New <code>lazy_value</code> for parameters","text":"<ul> <li>New marker <code>lazy_value</code> for <code>parametrize_plus</code>. Fixes #92</li> </ul>"},{"location":"changelog/#1150-better-parametrize_plus-and-smaller-dependencies","title":"1.15.0 - better <code>parametrize_plus</code> and smaller dependencies","text":"<ul> <li> <p>Better support for <code>pytest.param</code> in <code>parametrize_plus</code> and also in <code>fixture_union</code> and <code>fixture_param[s]</code>. Improved corresponding ids. Fixed #79 and #86</p> </li> <li> <p>New <code>@ignore_unused</code> decorator to protect a fixture function from the \"NOT_USED\" case happening when the fixture is used in a fixture union.</p> </li> <li> <p>Removed <code>six</code>, <code>wrapt</code> and <code>enum34</code> dependencies</p> </li> <li> <p>(Internal) submodules reorganization for readability</p> </li> <li>(Internal) suppressed a lot of code quality warnings</li> </ul>"},{"location":"changelog/#1140-bugfixes-and-hook-feature","title":"1.14.0 - bugfixes and hook feature","text":"<ul> <li> <p>Fixed <code>ids</code> precedence order when using <code>pytest.mark.parametrize</code> in a <code>fixture_plus</code>. Fixed #87</p> </li> <li> <p>Fixed issue with <code>fixture_union</code> when using the same fixture twice in it. Fixes #85</p> </li> <li> <p>Added the possibility to pass a <code>hook</code> function in all API where fixtures are created behind the scenes, so as to ease debugging and/or save fixtures (with <code>stored_fixture</code> from pytest harvest). Fixes #83</p> </li> <li> <p>Fixture closures now support reordering when no unions are present. This suppressed the annoying warning \"WARNING the new order is not taken into account !!\" when it was not relevant. Fixes #81</p> </li> </ul>"},{"location":"changelog/#1131-packaging-improvements","title":"1.13.1 - packaging improvements","text":"<ul> <li>packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the <code>setup.py</code>. In particular removed dependency to <code>six</code> for setup and added <code>py.typed</code> file. Fixes #78</li> </ul>"},{"location":"changelog/#1130-cases_generator-default-names","title":"1.13.0 - <code>@cases_generator</code> default <code>names</code>","text":"<p><code>@cases_generator</code> now has a default value for the <code>names</code> template, based on the parameters. Fixes #77.</p>"},{"location":"changelog/#1124-bugfix","title":"1.12.4 - Bugfix","text":"<p>Fixed <code>ValueError</code> when a product of unions was used on a test node, for example when two <code>parametrize_plus</code> using <code>fixture_ref</code>s were used on the same fixture or test function. Fixed #76</p>"},{"location":"changelog/#1123-improved-error-messages","title":"1.12.3 - Improved error messages","text":"<p>Improved error message when something that is not a fixture is used in <code>unpack_fixture</code> or <code>fixture_union</code>. Fixed #75</p>"},{"location":"changelog/#1122-warning-fix","title":"1.12.2 - Warning fix","text":"<p>Fixed deprecation warning #74</p>"},{"location":"changelog/#1121-bugfixes","title":"1.12.1 - Bugfixes","text":"<ul> <li> <p>Now using module name and not file path to detect symbols in cases files that are imported from elsewhere and not created locally. Indeed that was causing problems on some ^platforms where a <code>.pyc</code> cache file is created. Fixes #72</p> </li> <li> <p>Fixed <code>PluginValidationError</code> when <code>pytest_fixture_plus</code> or <code>pytest_parametrize_plus</code> were used in a <code>conftest.py</code> file. Fixes #71. According to discussion in pytest#6475, <code>pytest_fixture_plus</code> and <code>pytest_parametrize_plus</code> are now renamed to <code>fixture_plus</code> and <code>parametrize_plus</code> in order for pytest (pluggy) not to think they are hooks. Old aliases will stay around for a few versions, with a deprecation warning.</p> </li> </ul>"},{"location":"changelog/#1120-better-test-ids-for-parametrized-tests-with-fixture-refs-bugfix","title":"1.12.0 - better test ids for parametrized tests with fixture refs + bugfix","text":"<ul> <li> <p>Improved test ids for the cases where <code>fixture_ref</code> is used in the parameters list in <code>@pytest_parametrize_plus</code>. Fixed #69. Thanks <code>last-partizan</code> for the suggestion !</p> </li> <li> <p>Fixed <code>TypeError: got an unexpected keyword argument 'indirect'</code> with <code>pytest</code> 5+. Fixed #70.</p> </li> </ul>"},{"location":"changelog/#1119-bugfix","title":"1.11.9 - bugfix","text":"<p><code>FixtureClosureNode</code> is now able to properly handle <code>ignore_args</code>, and now supports that plugins append fixtures to the closure, such as pytest-asyncio. Added corresponding tests. Fixes #68</p>"},{"location":"changelog/#1118-bugfix","title":"1.11.8 - bugfix","text":"<p>Fixed <code>KeyError</code> issue happening when a fixture is not found. Now users will see the \"normal\" error message from pytest (<code>\"fixture &lt;name&gt; not found\"</code>). Fixed #67.</p>"},{"location":"changelog/#1117-bugfix","title":"1.11.7 - bugfix","text":"<p>Fixed <code>ValueError</code> issue happening with indirectly parametrized fixtures. Fixed #64.</p>"},{"location":"changelog/#1116-pyprojecttoml","title":"1.11.6 - pyproject.toml","text":"<p>raddessi added a <code>pyproject.toml</code> - thanks! Fixed #65.</p>"},{"location":"changelog/#1115-bugfix","title":"1.11.5 - bugfix","text":"<p><code>pytest_parametrize_plus</code> was not working correctly with test classes, leading to <code>fixture 'self' not found</code>. Fixed #63.</p>"},{"location":"changelog/#1114-python-2-bugfix","title":"1.11.4 - python 2 bugfix","text":"<p>Fixed issue happening with <code>@pytest.mark.parametrize</code> with python 2. Fixed #62.</p>"},{"location":"changelog/#1113-minor-improvements","title":"1.11.3 - minor improvements","text":"<p>Better error message when users use <code>THIS_MODULE</code> in <code>cases=</code> instead of <code>module=</code>.</p> <p>Added <code>__version__</code> package-level attribute.</p>"},{"location":"changelog/#1112-increased-tolerance-to-other-plugins-bugfix","title":"1.11.2 - Increased tolerance to other plugins + bugfix","text":"<p>Now when other plugins try to manipulate the fixture closure, warning messages are emitted but no error is raised. Fixed #55.</p> <p>Also fixed issue #58 happening with doctest.</p>"},{"location":"changelog/#1111-added-six-dependency-explicitly","title":"1.11.1 - Added <code>six</code> dependency explicitly","text":"<p>It was missing from <code>setup.py</code>.</p>"},{"location":"changelog/#1110-fixture_ref-can-now-be-used-inside-tuples-leading-to-cross-products","title":"1.11.0 - <code>fixture_ref</code> can now be used inside tuples, leading to cross-products","text":"<p>Fixes #47.</p>"},{"location":"changelog/#1102-more-intuitive-error-messages","title":"1.10.2 - More intuitive error messages","text":"<p>Now raising an explicit <code>InvalidParamsList</code> when pytest parametrize <code>argvalues</code> are incorrect. See #54</p>"},{"location":"changelog/#1101-bugfix","title":"1.10.1 - Bugfix","text":"<p>Fixed #52.</p>"},{"location":"changelog/#1100-new-feature-fixtures-unpacking","title":"1.10.0 - New feature: fixtures unpacking","text":"<p>You can now unpack a fixture iterable into several individual fixtures using <code>unpack_fixture</code> or using <code>@pytest_fixture_plus(unpack_into=&lt;names&gt;)</code>. This is also available in <code>union_fixture(unpack_into=&lt;names&gt;)</code>. Fixed #50 and #51.</p>"},{"location":"changelog/#193-bugfix","title":"1.9.3 - Bugfix","text":"<p>Fixed issues when parametrize argnames contains a list. This fixed #49</p>"},{"location":"changelog/#192-bugfix-with-pytest-37","title":"1.9.2 - Bugfix with pytest 3.7","text":"<p>Fixed #48.</p>"},{"location":"changelog/#191-bugfix-with-pytest-37","title":"1.9.1 - Bugfix with pytest 3.7","text":"<p>Fixed #48.</p>"},{"location":"changelog/#190-new-with-reorder-commandline-option","title":"1.9.0 - New <code>--with-reorder</code> commandline option","text":"<p>New commandline option '--with-reorder' to change the reordering strategy currently in application. Fixes #45.</p> <p>The <code>--with-reorder</code> \"skip\" mode was not working correctly in presence of marks, fixed it. Fixed #46.</p>"},{"location":"changelog/#181-bugfixes","title":"1.8.1 - BugFixes","text":"<p>Ids should not be used when setting a NOT_USED parametrization. Fixes #43</p> <p>Fixed issue with ordering and setup/teardown for higher-level scope fixtures (session and module scopes) when using union fixtures. Fixes #44</p>"},{"location":"changelog/#180-better-ids-for-fixture-unions","title":"1.8.0 - Better ids for fixture unions","text":"<p>New:</p> <ul> <li><code>fixture_union</code> now accept a non-<code>None</code> value for <code>ids</code>. It also has a new <code>idstyle</code> argument allowing users to change the style of ids used. Finally <code>pytest_parametrize_plus</code> relies on this <code>ids</code> argument to set a more readable list of ids for the created union. Fixes #41.</li> </ul> <p>Misc:</p> <ul> <li>Added non-regression test for fixture order. It passes already for all recent pytest versions (after 3.3). Fixes #42</li> </ul>"},{"location":"changelog/#170-new-pytest_parametrize_plus-allowing-fixture-references-to-be-used-in-parameter-values","title":"1.7.0 - New <code>@pytest_parametrize_plus</code> allowing fixture references to be used in parameter values","text":"<p>New decorator <code>@pytest_parametrize_plus</code> able to handle the case where a <code>fixture_ref(&lt;fixture_name&gt;)</code> is present in the parameter values list. This decorator can be applied both on test functions and fixtures (if they are decorated with <code>@pytest_fixture_plus</code>). Fixes #40</p> <p>Major refactoring of the \"union fixtures\" mechanism.</p> <ul> <li>The <code>NOT_USED</code> status is now correctly propagated between dependent fixtures. This should fix a few cases where user fixtures were setup/teardown while not used in the current test node.</li> <li>Empty fixture unions are not permitted anymore.</li> <li>The way unions are handled in test parametrization was redesigned. The new design is based on a two-steps approach: first build the fixture closure for each node as a tree (and not a list as in <code>pytest</code>), and then apply parametrization intelligently based on this tree structure. This fixes several unintuitive behaviours that were happening with unions.</li> </ul> <p>Note: interestingly this also fixes pytest#5054.</p>"},{"location":"changelog/#163-minor-exception-enhancement","title":"1.6.3 - Minor exception enhancement","text":"<p>Improved the error message when the name template is wrong in <code>@cases_generator</code>. Fixes #39.</p>"},{"location":"changelog/#162-bug-fixes","title":"1.6.2 - bug fixes","text":"<p><code>fixture_union</code>:</p> <ul> <li> <p>Changed the repr of <code>NOT_USED</code> to <code>pytest_cases.NOT_USED</code>.</p> </li> <li> <p><code>@pytest_fixture_plus</code> now correctly handles the <code>NOT_USED</code> when fixtures in the union do not contain any parameter. Fixes #38.</p> </li> </ul> <p><code>param_fixtures</code>:</p> <ul> <li> <p><code>param_fixtures</code> now delegates to <code>param_fixture</code> when a single parameter name is provided. This is more consistent. Fixed #36.</p> </li> <li> <p><code>param_fixture[s]</code> now support all arguments from <code>fixture</code> (<code>scope</code> and <code>autouse</code> in particular).</p> </li> </ul>"},{"location":"changelog/#161-pytest_fixture_plus-improvement-to-handle-not_used-cases","title":"1.6.1 - <code>@pytest_fixture_plus</code> improvement to handle <code>NOT_USED</code> cases","text":"<p>Fixed issue where fixtures get called with <code>NOT_USED</code> as a parameter when using a <code>fixture_union</code>. This issue is actually only fixed in <code>@pytest_fixture_plus</code>, if you use <code>@pytest.fixture</code> you have to handle it manually. Fixes #37.</p>"},{"location":"changelog/#160-fixture_union-and-param_fixtures-bugfix","title":"1.6.0 - <code>fixture_union</code> and <code>param_fixture[s]</code> bugfix","text":"<p>New <code>fixture_union</code> method to create a fixture that is the union/combination of other fixtures. This is an attempt to solve this pytest proposal.</p> <p>Also, <code>param_fixture</code> and <code>param_fixtures</code> can now be used without necessarily storing the return value into a variable: they will automatically register the created fixtures in the calling module.  </p> <p>Finally, fixed a bug with <code>param_fixtures</code> when called to create a fixture for a single parameter.</p>"},{"location":"changelog/#151-param_fixtures-bugfix","title":"1.5.1 - <code>param_fixtures</code> bugfix","text":"<p>Fixed <code>param_fixtures</code> issue: all parameter values were identical to the last parameter of the tuple. Fixes #32.</p>"},{"location":"changelog/#150-new-helpers-param_fixture-and-param_fixtures","title":"1.5.0 - new helpers <code>param_fixture</code> and <code>param_fixtures</code>","text":"<p>Following Sup3rGeo's proposal, introduced two helper methods to create simple \"parameter fixtures\". Fixes #31.</p>"},{"location":"changelog/#142-parametrized-pytest_fixture_plus-minor-bug-fix","title":"1.4.2 - parametrized <code>@pytest_fixture_plus</code> minor bug fix","text":"<p><code>@pytest_fixture_plus</code> now correctly honors parameter id and marks overridden at single parameter level using <code>pytest.param</code>. Fixed #30.</p>"},{"location":"changelog/#141-parametrized-pytest_fixture_plus-minor-bug-fix","title":"1.4.1 - parametrized <code>@pytest_fixture_plus</code> minor bug fix","text":"<p>Fixed <code>@pytest_fixture_plus</code> in case it is used with <code>parametrize</code> and one parameter is itself customized using <code>pytest.param</code>. Fixed #29.</p>"},{"location":"changelog/#140-pytest_fixture_plus-major-improvement","title":"1.4.0 - <code>@pytest_fixture_plus</code> major improvement","text":"<ul> <li> <p>Major improvement of <code>@pytest_fixture_plus</code>: instead of generating fixtures, it now correctly parametrizes the fixture. Skip/fail Marks are correctly copied too. Fixes #28.</p> </li> <li> <p><code>pytest_fixture_plus</code> does not accept the <code>params</code> and <code>ids</code> arguments any more, it only relies on parametrization marks.</p> </li> </ul>"},{"location":"changelog/#133-parametrized-pytest_fixture_plus-bugfix","title":"1.3.3 - parametrized <code>@pytest_fixture_plus</code> Bugfix","text":"<p>Fixed minor bug with parametrized <code>@pytest_fixture_plus</code>: spaces are now correctly removed when multiple parameter names are provided in the same <code>parametrize</code> call. Fixes #27.</p>"},{"location":"changelog/#132-parametrized-pytest_fixture_plus-bugfix","title":"1.3.2 - parametrized <code>@pytest_fixture_plus</code> Bugfix","text":"<p>Fixed bug with <code>@pytest_fixture_plus</code> when used in parametrized mode. Fixes #26. Thanks Sup3rGeo!</p>"},{"location":"changelog/#131-minor-dependency-change","title":"1.3.1 - Minor dependency change","text":"<p>Now using <code>decopatch</code> to create the decorators.</p>"},{"location":"changelog/#130-more-flexible-case-generators-names-minor-dependency-change","title":"1.3.0 - More flexible case generators names + Minor dependency change","text":"<p>Cases generators can now support explicit name lists, and name generator callables, in addition to the name template strings. Fixed #24.</p> <p>Dependency to <code>decorator</code> has been dropped and replaced with <code>makefun</code>. Fixed #25.</p>"},{"location":"changelog/#122-fixed-bug-with-marks-on-cases-with-pytest-33","title":"1.2.2 - fixed bug with marks on cases with pytest 3.3","text":"<p>Marks on cases are now also working with pytest 3.3. Fixed #23.</p> <p>Ids for marked tests are now better managed. A new function <code>get_pytest_parametrize_args</code> is now used to transform the list of cases obtained by <code>get_all_cases(module)</code>, into the list of marked cases and ids required by <code>@pytest.mark.parametrize</code>. The doc has been updated to explain this for advanced users wishing to perform this step manually.</p>"},{"location":"changelog/#121-fixed-id-of-test-cases-with-marks","title":"1.2.1 - fixed id of test cases with marks","text":"<p>Id of test cases with marks was appearing as <code>ParameterSet</code>. Fixed it.</p>"},{"location":"changelog/#120-pytestmark-can-be-used-on-cases-pytest_fixture_plus-parametrization-order-bugfix","title":"1.2.0 - @pytest.mark can be used on cases + @pytest_fixture_plus parametrization order bugfix","text":"<p>Pytest marks such as <code>@pytest.mark.skipif</code> can now be used on case functions. As a consequence, <code>get_all_cases</code> is now the recommended function to use instead of <code>extract_cases_from_module</code> to perform manual collection. Indeed <code>get_all_cases</code> correctly prepares the resulting parameters list so that pytest sees the marks. Fixed #21. </p> <p>Fixed parametrization order when <code>@pytest_fixture_plus</code> is used with several <code>@pytest.mark.parametrize</code>. Fixed #22.</p>"},{"location":"changelog/#111-improved-generated-fixture-names-for-pytest_fixture_plus","title":"1.1.1 - Improved generated fixture names for <code>@pytest_fixture_plus</code>","text":"<p>When <code>@pytest_fixture_plus</code> is used on a function marked as parametrized, some fixtures are generated (one for each parameter). Generated fixture names now follow the pattern <code>&lt;fixturename&gt;__&lt;paramname&gt;</code>. Fixed #20.</p>"},{"location":"changelog/#110-new-pytest_fixture_plus","title":"1.1.0 - New <code>@pytest_fixture_plus</code>","text":"<p>New decorator <code>@pytest_fixture_plus</code> allows to use several <code>@pytest.mark.parametrize</code> on a fixture. Therefore one can use multiple <code>@cases_data</code> decorators, too. Fixes #19. Note: this is a temporary feature, that will be removed if/when pytest supports it.</p>"},{"location":"changelog/#100-cases_fixture-pytest-2x-support","title":"1.0.0 - <code>@cases_fixture</code> + pytest 2.x support","text":"<p>Pytest 2.x is now supported. Fixes #14.</p> <p>New feature: <code>@cases_fixture</code> ! Now you can put your cases data retrieval in a fixture so that its duration does not enter into the test duration. This is particularly interesting if you use pytest-harvest to create benchmarks: you probably do not want the case data retrieval/parsing to be counted in the test duration, especially if you use caching on the case function to accelerate subsequent retrievals. Fixes #15.</p>"},{"location":"changelog/#0101-minor-encoding-issue-in-setuppy","title":"0.10.1 - minor encoding issue in setup.py","text":""},{"location":"changelog/#0100-support-for-python-2","title":"0.10.0 - support for python 2","text":"<p>Python 2 is now supported. Fixed #3. </p> <ul> <li>Note: <code>CaseData</code>, <code>Given</code>, <code>ExpectedNormal</code>, <code>ExpectedError</code>, and <code>MultipleStepsCaseData</code> type hints is not created in python 2 and python&lt;3.5</li> </ul>"},{"location":"changelog/#091-pytest-steps-is-now-an-independent-project","title":"0.9.1 - pytest-steps is now an independent project","text":"<ul> <li>Light refactoring: some internal function names are now private, and there are now two submodules.</li> <li>pytest-steps is now an independent project. Examples in the documentation have been updated</li> <li>New documentation page: API reference</li> </ul>"},{"location":"changelog/#080-filtering-can-now-be-done-using-a-callable","title":"0.8.0 - Filtering can now be done using a callable.","text":"<ul> <li><code>@cases_data</code>: the <code>filter</code> argument now contains a filtering function. WARNING: the previous behaviour is still available but has been renamed <code>has_tag</code>. Fixes #8.</li> </ul>"},{"location":"changelog/#070-hardcoded-cases-selection-and-multi-module-selection","title":"0.7.0 - Hardcoded cases selection, and multi-module selection","text":"<ul> <li><code>@cases_data</code> has a new parameters <code>cases</code> that can be used to hardcode a case or a list of cases. Its <code>module</code> parameter can also now take a list of modules</li> </ul>"},{"location":"changelog/#060-case-parameters-and-better-test-suites","title":"0.6.0 - Case parameters and better test suites","text":"<ul> <li><code>get_for</code> is deprecated: it was too specific to a given case data format.</li> <li><code>MultipleStepsCaseData</code> was fixed to also support multiple inputs.</li> <li>Case functions can now have parameters (even case generators). This is particularly useful for test suites. Fixes #9.</li> </ul>"},{"location":"changelog/#050-support-for-test-suites","title":"0.5.0 - support for test suites","text":"<ul> <li>test functions can now be decorated with <code>@test_steps</code> to easily define a test suite with several steps. This fixes #7.</li> </ul>"},{"location":"changelog/#040-support-for-data-caching-with-lru_cache","title":"0.4.0 - support for data caching with lru_cache","text":"<ul> <li>cases can now be decorated with <code>@lru_cache</code>. <code>@cases_generator</code> also provides a <code>lru_cache</code> parameter to enable caching. Fixes #6.</li> </ul>"},{"location":"changelog/#030-case-generators","title":"0.3.0 - case generators","text":"<ul> <li>New decorator <code>@cases_generator</code> to define case generators. Fixes #1.</li> <li>Also, removed unused functions <code>is_expected_error_instance</code> and <code>assert_exception_equal</code></li> </ul>"},{"location":"changelog/#020-this_module-constant-taggingfiltering-doc","title":"0.2.0 - THIS_MODULE constant + Tagging/Filtering + doc","text":"<ul> <li> <p>New constant <code>THIS_MODULE</code> so that cases and test functions can coexist in the same file. This fixes #5.</p> </li> <li> <p>Added <code>@test_target</code> and <code>@case_tags</code> decorators for case functions, and added <code>filter</code> parameter in <code>@cases_data</code>. This allows users to :</p> <ul> <li>tag a case function with any item (and in particular with the reference to the function it relates to), </li> <li>and to filter the case functions used by a test function according to a particular tag.</li> </ul> </li> </ul> <p>This fixes #4.</p> <ul> <li>Improved documentation</li> </ul>"},{"location":"changelog/#010-first-public-version","title":"0.1.0 - First public version","text":"<ul> <li>Initial fork from private repo</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Our examples are hosted in a separate repository so that they can be updated independently.</p> <ul> <li>data science benchmark demonstrates how <code>pytest</code> can be used as a benchmarking engine thanks to <code>pytest-cases</code> and <code>pytest-harvest</code>, to compare the performances of several regression algorithms on several datasets and produce various reports (plots, csv table...).</li> </ul>"},{"location":"long_description/","title":"pytest-cases","text":"<p>Separate test code from test cases in <code>pytest</code>.</p> <p>The documentation for users is available here: https://smarie.github.io/python-pytest-cases/</p> <p>A readme for developers is available here: https://github.com/smarie/python-pytest-cases</p>"},{"location":"pytest_goodies/","title":"<code>pytest</code> Goodies","text":"<p>Many <code>pytest</code> features were missing to make <code>pytest_cases</code> work with such a \"no-boilerplate\" experience. Many of these can be of interest to the general <code>pytest</code> audience, so they are exposed in the public API.</p>"},{"location":"pytest_goodies/#fixture","title":"<code>@fixture</code>","text":"<p><code>@fixture</code> is similar to <code>pytest.fixture</code> but without its <code>param</code> and <code>ids</code> arguments. Instead, it is able to pick the parametrization from <code>@pytest.mark.parametrize</code> marks applied on fixtures. This makes it very intuitive for users to parametrize both their tests and fixtures. As a bonus, its <code>name</code> argument works even in old versions of pytest (which is not the case for <code>fixture</code>).</p> <p>Finally it now supports unpacking, see unpacking feature.</p> <p><code>@fixture</code> deprecation if/when <code>@pytest.fixture</code> supports <code>@pytest.mark.parametrize</code></p> <p>The ability for pytest fixtures to support the <code>@pytest.mark.parametrize</code> annotation is a feature that clearly belongs to <code>pytest</code> scope, and has been requested already. It is therefore expected that <code>@fixture</code> will be deprecated in favor of <code>@pytest_fixture</code> if/when the <code>pytest</code> team decides to add the proposed feature. As always, deprecation will happen slowly across versions (at least two minor, or one major version update) so as for users to have the time to update their code bases.</p>"},{"location":"pytest_goodies/#unpack_fixture-unpack_into","title":"<code>unpack_fixture</code> / <code>unpack_into</code>","text":"<p>In some cases fixtures return a tuple or a list of items. It is not easy to refer to a single of these items in a test or another fixture. With <code>unpack_fixture</code> you can easily do it:</p> <pre><code>import pytest\nfrom pytest_cases import unpack_fixture, fixture\n\n@fixture\n@pytest.mark.parametrize(\"o\", ['hello', 'world'])\ndef c(o):\n    return o, o[0]\n\na, b = unpack_fixture(\"a,b\", c)\n\ndef test_function(a, b):\n    assert a[0] == b\n</code></pre> <p>Note that you can also use the <code>unpack_into=</code> argument of <code>@fixture</code> to do the same thing:</p> <pre><code>import pytest\nfrom pytest_cases import fixture\n\n@fixture(unpack_into=\"a,b\")\n@pytest.mark.parametrize(\"o\", ['hello', 'world'])\ndef c(o):\n    return o, o[0]\n\ndef test_function(a, b):\n    assert a[0] == b\n</code></pre> <p>And it is also available in <code>fixture_union</code>:</p> <pre><code>import pytest\nfrom pytest_cases import fixture, fixture_union\n\n@fixture\n@pytest.mark.parametrize(\"o\", ['hello', 'world'])\ndef c(o):\n    return o, o[0]\n\n@fixture\n@pytest.mark.parametrize(\"o\", ['yeepee', 'yay'])\ndef d(o):\n    return o, o[0]\n\nfixture_union(\"c_or_d\", [c, d], unpack_into=\"a, b\")\n\ndef test_function(a, b):\n    assert a[0] == b\n</code></pre>"},{"location":"pytest_goodies/#param_fixtures","title":"<code>param_fixture[s]</code>","text":"<p>If you wish to share some parameters across several fixtures and tests, it might be convenient to have a fixture representing this parameter. This is relatively easy for single parameters, but a bit harder for parameter tuples.</p> <p>The two utilities functions <code>param_fixture</code> (for a single parameter name) and <code>param_fixtures</code> (for a tuple of parameter names) handle the difficulty for you:</p> <pre><code>import pytest\nfrom pytest_cases import param_fixtures, param_fixture\n\n# create a single parameter fixture\nmy_parameter = param_fixture(\"my_parameter\", [1, 2, 3, 4])\n\n@pytest.fixture\ndef fixture_uses_param(my_parameter):\n    ...\n\ndef test_uses_param(my_parameter, fixture_uses_param):\n    ...\n\n# -----\n# create a 2-tuple parameter fixture\narg1, arg2 = param_fixtures(\"arg1, arg2\", [(1, 2), (3, 4)])\n\n@pytest.fixture\ndef fixture_uses_param2(arg2):\n    ...\n\ndef test_uses_param2(arg1, arg2, fixture_uses_param2):\n    ...\n</code></pre> <p>You can mark any of the argvalues with <code>pytest.mark</code> to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in <code>pytest</code>. See pytest documentation.</p>"},{"location":"pytest_goodies/#fixture_union","title":"<code>fixture_union</code>","text":"<p>As of <code>pytest</code> 5, it is not possible to create a \"union\" fixture, i.e. a parametrized fixture that would first take all the possible values of fixture A, then all possible values of fixture B, etc. Indeed all fixture dependencies (a.k.a. \"closure\") of each test node are grouped together, and if they have parameters a big \"cross-product\" of the parameters is done by <code>pytest</code>.</p> <p>The topic has been largely discussed in pytest-dev#349 and a request for proposal has been finally made.</p> <p><code>fixture_union</code> is an implementation of this proposal. It is also used by <code>@parametrize</code> to support <code>fixture_ref</code> in parameter values, see below. The theory is presented in more details in this page, while below are more practical examples.</p> <pre><code>from pytest_cases import fixture, fixture_union\n\n@fixture\ndef first():\n    return 'hello'\n\n@fixture(params=['a', 'b'])\ndef second(request):\n    return request.param\n\n# c will first take all the values of 'first', then all of 'second'\nc = fixture_union('c', [first, second])\n\ndef test_basic_union(c):\n    print(c)\n</code></pre> <p>yields</p> <pre><code>&lt;...&gt;::test_basic_union[\\first] hello   PASSED\n&lt;...&gt;::test_basic_union[\\second-a] a    PASSED\n&lt;...&gt;::test_basic_union[\\second-b] b    PASSED\n</code></pre>"},{"location":"pytest_goodies/#idstyle","title":"idstyle","text":"<p>As you can see the ids of union fixtures are slightly different from standard ids, so that you can easily understand what is going on. You can change this feature with <code>\u00ecdstyle</code>, see API documentation for details.</p>"},{"location":"pytest_goodies/#marks-and-ids","title":"marks and ids","text":"<p>You can mark any of the alternatives with <code>pytest.mark</code> to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in <code>pytest</code>. See pytest documentation.</p>"},{"location":"pytest_goodies/#unpacking","title":"unpacking","text":"<p>Fixture unions also support unpacking with the <code>unpack_into</code> argument, see unpacking feature.</p>"},{"location":"pytest_goodies/#to-conclude","title":"to conclude","text":"<p>Fixture unions are a major change in the internal pytest engine, as fixture closures (the ordered set of all fixtures required by a test node to run - directly or indirectly) now become trees where branches correspond to alternative paths taken in the \"unions\", and leafs are the alternative fixture closures. This feature has been tested in very complex cases (several union fixtures, fixtures that are not selected by a given union but that is requested by the test function, etc.). But if you find some strange behaviour don't hesitate to report it in the issues page !</p> <p>IMPORTANT if you do not use <code>@fixture</code> but only <code>@pytest.fixture</code>, then you will see that your fixtures are called even when they are not used, with a parameter <code>NOT_USED</code>. This symbol is automatically ignored if you use <code>@fixture</code>, otherwise you have to handle it. Alternatively you can use <code>@ignore_unused</code> on your fixture function.</p> <p>fixture unions vs. cases</p> <p>If you're familiar with <code>pytest-cases</code> already, you might note that <code>@cases_data</code> is not so different than a fixture union: we do a union of all case functions. If one day union fixtures are directly supported by <code>pytest</code>, we will probably refactor this lib to align all the concepts.</p>"},{"location":"pytest_goodies/#parametrize","title":"<code>@parametrize</code>","text":"<p><code>@parametrize</code> is a replacement for <code>@pytest.mark.parametrize</code> with many additional features to make the most of parametrization. See API reference for details about all the new features. In particular it allows you to include references to fixtures and to value-generating functions in the parameter values. </p> <ul> <li>Simply use <code>fixture_ref(&lt;fixture&gt;)</code> in the parameter values, where <code>&lt;fixture&gt;</code> can be the fixture name or fixture function. New: from version <code>3.2</code> on, if <code>auto_refs=True</code> (default), <code>@parametrize</code> will automatically detect fixture symbols in the list of argvalues, and will create <code>fixture_ref</code>s automatically around them so that you don't need to.</li> <li>if you do not wish to create a fixture, you can also use <code>lazy_value(&lt;function&gt;)</code></li> <li>Note that when parametrizing several argnames, both <code>fixture_ref</code> and <code>lazy_value</code> can be used as the tuple, or in the tuple. Several <code>fixture_ref</code> and/or <code>lazy_value</code> can be used in the same tuple, too.</li> <li>By default the id associated with a <code>fixture_ref</code> or a <code>lazy_value</code> is the name of the fixture or function. Custom ids can be passed with the <code>id=&lt;id&gt;</code> parameter. </li> </ul> <p>For example, with a single argument:</p> <pre><code>import pytest\nfrom pytest_cases import parametrize, fixture, fixture_ref, lazy_value\n\n@pytest.fixture\ndef world_str():\n    return 'world'\n\ndef whatfun():\n    return 'what'\n\n@fixture\n@parametrize('who', [world_str, 'you'])\ndef greetings(who):\n    return 'hello ' + who\n\n@parametrize('main_msg', ['nothing', \n                          fixture_ref(world_str),\n                          lazy_value(whatfun),\n                          \"1\",\n                          fixture_ref(greetings)], \n             auto_refs=False)\n@pytest.mark.parametrize('ending', ['?', '!'])\ndef test_prints(main_msg, ending):\n    print(main_msg + ending)\n</code></pre> <p>yields the following</p> <pre><code>&gt; pytest -s -v\ncollected 12 items\ntest_prints[nothing-?] PASSED                   [  8%]nothing?\ntest_prints[nothing-!] PASSED                   [ 16%]nothing!\ntest_prints[world_str-?] PASSED                 [ 25%]world?\ntest_prints[world_str-!] PASSED                 [ 33%]world!\ntest_prints[whatfun-?] PASSED                   [ 41%]what?\ntest_prints[whatfun-!] PASSED                   [ 50%]what!\ntest_prints[1-?] PASSED                         [ 58%]1?\ntest_prints[1-!] PASSED                         [ 66%]1!\ntest_prints[greetings-world_str-?] PASSED       [ 75%]hello world?\ntest_prints[greetings-world_str-!] PASSED       [ 83%]hello world!\ntest_prints[greetings-you-?] PASSED             [ 91%]hello you?\ntest_prints[greetings-you-!] PASSED             [100%]hello you!\n</code></pre>"},{"location":"pytest_goodies/#ids-and-marks","title":"ids and marks","text":"<p>You can also mark any of the argvalues with <code>pytest.param</code> to pass a custom id or a custom \"skip\" or \"fail\" mark, just as you do in <code>pytest</code>. See pytest documentation.</p> <p>You can also pass a custom callable or generator in <code>ids</code> as in <code>@pytest.mark.parametrize</code>.</p>"},{"location":"pytest_goodies/#idstyle-customization","title":"idstyle customization","text":"<p>As you can see in the example above, the default ids are similar to what you would intuitively expect, even when you use <code>fixture_ref</code>.</p> <p>This is because by default <code>idstyle=None</code>, to preserve test ids very close to standard <code>pytest</code> by default. But still, a <code>fixture_union</code> is generated behind the scenes when there is a fixture reference. So this is actually non-standard. You may therefore prefer to see explicit ids showing the various fixture alternatives, as in <code>fixture_union</code>. For this simply set the <code>idstyle</code> to <code>'compact'</code>, <code>'explicit'</code> or to a callable such as <code>str</code>.</p> <p>For example, changing the previous example to add <code>idstyle=\"explicit\"</code>:</p> <pre><code>(...same as above...)\n\n@parametrize('main_msg', ['nothing',\n                          fixture_ref(world_str),\n                          lazy_value(whatfun),\n                          \"1\",\n                          fixture_ref(greetings)], idstyle=\"explicit\")\n@pytest.mark.parametrize('ending', ['?', '!'])\ndef test_prints(main_msg, ending):\n    print(main_msg + ending)\n</code></pre> <p>yields to </p> <pre><code>&gt; pytest -s -v\ncollected 12 items\ntest_prints[main_msg\\nothing-?] PASSED                [  8%]nothing?\ntest_prints[main_msg\\nothing-!] PASSED                [ 16%]nothing!\ntest_prints[main_msg\\world_str-?] PASSED              [ 25%]world?\ntest_prints[main_msg\\world_str-!] PASSED              [ 33%]world!\ntest_prints[main_msg\\P2:4-whatfun-?] PASSED           [ 41%]what?\ntest_prints[main_msg\\P2:4-whatfun-!] PASSED           [ 50%]what!\ntest_prints[main_msg\\P2:4-1-?] PASSED                 [ 58%]1?\ntest_prints[main_msg\\P2:4-1-!] PASSED                 [ 66%]1!\ntest_prints[main_msg\\greetings-world_str-?] PASSED    [ 75%]hello world?\ntest_prints[main_msg\\greetings-world_str-!] PASSED    [ 83%]hello world!\ntest_prints[main_msg\\greetings-you-?] PASSED          [ 91%]hello you?\ntest_prints[main_msg\\greetings-you-!] PASSED          [100%]hello you!\n</code></pre> <p>You can see that with this explicit style, the various \"alternatives\" in the fixture union generated behind the scenes for the <code>main_msg</code> parameter appear explicitly. In particular you see that there is an alternative <code>main_msg\\P2:4</code> covering several parameters in a row.</p> <p>Note that this <code>idstyle</code> is not taken into account if you only use <code>lazy_value</code>s but no <code>fixture_ref</code>, as <code>lazy_value</code>s do not require to create a fixture union behind the scenes.</p>"},{"location":"pytest_goodies/#parametrization-order","title":"parametrization order","text":"<p>Another consequence of using <code>fixture_ref</code> is that the priority order of the parameters, relative to other standard <code>pytest.mark.parametrize</code> parameters that you would place on the same function, will get impacted. You may solve this by replacing your other <code>@pytest.mark.parametrize</code> calls with <code>param_fixture</code>s so that all the parameters are fixtures (see <code>param_fixture</code>).</p>"},{"location":"pytest_goodies/#passing-a-hook","title":"passing a <code>hook</code>","text":"<p>As per version <code>1.14</code>, all the above functions now support passing a <code>hook</code> argument. This argument should be a callable. It will be called every time a fixture is about to be created by <code>pytest_cases</code> on your behalf. The fixture function is passed as the argument of the hook, and the hook should return it as the result.</p> <p>You can use this fixture to better understand which fixtures are created behind the scenes, and also to decorate the fixture functions before they are created. For example you can use <code>hook=saved_fixture</code> (from <code>pytest-harvest</code>) in order to save the created fixtures in the fixture store.  </p>"},{"location":"pytest_goodies/#assert_exception","title":"<code>assert_exception</code>","text":"<p><code>assert_exception</code> context manager is an alternative to <code>pytest.raises</code> to check exceptions in your tests. You can either check type, instance equality, repr string pattern, or use custom validation functions. See API reference.</p>"},{"location":"pytest_goodies/#-with-reorder","title":"<code>--with-reorder</code>","text":"<p><code>pytest</code> postprocesses the order of the collected items in order to optimize setup/teardown of session, module and class fixtures. This optimization algorithm happens at the <code>pytest_collection_modifyitems</code> stage, and is still under improvement, as can be seen in pytest#3551, pytest#3393, #2846...</p> <p>Besides other plugins such as pytest-reorder can modify the order as well.</p> <p>This new commandline is a goodie to change the reordering:</p> <ul> <li> <p><code>--with-reorder normal</code> is the default behaviour: it lets pytest and all the plugins execute their reordering in each of their <code>pytest_collection_modifyitems</code> hooks, and simply does not interact </p> </li> <li> <p><code>--with-reorder skip</code> allows you to restore the original order that was active before <code>pytest_collection_modifyitems</code> was initially called, thus not taking into account any reordering done by pytest or by any of its plugins.</p> </li> </ul>"},{"location":"unions_theory/","title":"Theory behind <code>fixture_union</code>","text":""},{"location":"unions_theory/#1-how-pytest-works-today","title":"1. How <code>pytest</code> works today","text":"<p>As of <code>pytest</code> 5, there are three kind of concepts at play to generate the list of test nodes and their received parameters (\"call spec\" in pytest internals).</p> <ul> <li> <p>test functions are the functions defined with <code>def test_&lt;name&gt;(&lt;args&gt;)</code>.</p> </li> <li> <p>they can be parametrized using <code>@pytest.mark.parametrize</code> (or our enhanced version <code>@parametrize</code>). That means that some of the <code>&lt;args&gt;</code> will take several values, and for each combination a distinct test node will be created</p> </li> <li> <p>they can require fixtures, that is, functions decorated with <code>@pytest.fixture</code> (or our enhanced version <code>@fixture</code>). That means that some of the <code>&lt;args&gt;</code> will take the value of the corresponding fixture(s).</p> </li> <li> <p>fixtures can be parametrized too (with <code>@fixture</code> it is easier :) ), and can require other fixtures.</p> </li> <li> <p>finally fixtures can enable an \"auto-use\" mode, so that they are called even when not explicitly required by anything.</p> </li> </ul> <p>Therefore, a test plan can be represented as an acyclic directed graph of fixtures, where nodes are fixtures and edges represent dependencies. On top of this layout, we can overlay the information of which fixture nodes are parametrized, which ones are required by which test function, and which test function is parametrized. The resulting figure is presented below:</p> <p></p> <p>The following code can be used to easily check the number of tests run. Note that we use <code>@fixture</code> and <code>@parametrize</code> from <code>pytest-cases</code> to ease code readability here but you would get a similar behaviour with <code>@pytest.fixture</code> and <code>@pytest.mark.parametrize</code> (the test ids would not show the parameter names by default though, which is helpful for our demonstration here).</p> <pre><code>from pytest_cases import fixture, parametrize\n\n@fixture(autouse=True)\n@parametrize(ie=[-1, 1])\ndef e(ie):\n    return \"e%s\" % ie\n\n@fixture\ndef d():\n    return \"d\"\n\n@fixture\ndef c():\n    return \"c\"\n\n@fixture\n@parametrize(ia=[0, 1])\ndef a(c, d, ia):\n    return \"a%s\" % ia + c + d\n\n@parametrize(i2=['x', 'z'])\ndef test_2(a, i2):\n    assert (a + i2) in (\"a0cdx\", \"a0cdz\", \"a1cdx\", \"a1cdz\")\n\n@fixture\n@parametrize(ib=['x', 'z'])\ndef b(a, c, ib):\n    return \"b%s\" % ib + c + a\n\ndef test_1(a, b):\n    assert a in (\"a0cd\", \"a1cd\")\n    assert a == b[-4:]\n    assert b[:-4] in (\"bxc\", \"bzc\")\n</code></pre> <p>calling <code>pytest</code> yields:</p> <pre><code>============================= test session starts =============================\ncollecting ... collected 16 items\n\ntest_doc_fixture_graph.py::test_2[ie=-1-ia=0-i2=x] \ntest_doc_fixture_graph.py::test_2[ie=-1-ia=0-i2=z] \ntest_doc_fixture_graph.py::test_2[ie=-1-ia=1-i2=x] \ntest_doc_fixture_graph.py::test_2[ie=-1-ia=1-i2=z] \ntest_doc_fixture_graph.py::test_2[ie=1-ia=0-i2=x] \ntest_doc_fixture_graph.py::test_2[ie=1-ia=0-i2=z] \ntest_doc_fixture_graph.py::test_2[ie=1-ia=1-i2=x] \ntest_doc_fixture_graph.py::test_2[ie=1-ia=1-i2=z] \ntest_doc_fixture_graph.py::test_1[ie=-1-ia=0-ib=x] \ntest_doc_fixture_graph.py::test_1[ie=-1-ia=0-ib=z] \ntest_doc_fixture_graph.py::test_1[ie=-1-ia=1-ib=x] \ntest_doc_fixture_graph.py::test_1[ie=-1-ia=1-ib=z] \ntest_doc_fixture_graph.py::test_1[ie=1-ia=0-ib=x] \ntest_doc_fixture_graph.py::test_1[ie=1-ia=0-ib=z] \ntest_doc_fixture_graph.py::test_1[ie=1-ia=1-ib=x] \ntest_doc_fixture_graph.py::test_1[ie=1-ia=1-ib=z] \n\n============================= 16 passed in 0.14s ==============================\n</code></pre> <p>So each test is called 8 times. How are these calls computed ?</p> <ul> <li>first for each test, <code>pytest</code> computes the set of all fixtures that are directly or indirectly required to run it. This is known as the \"fixture closure\". So for <code>test_1</code> this closure is <code>{a, b, c, d, e}</code> while for test 2 it is <code>{a, c, d, e}</code>. We can show this on the following picture:</li> </ul> <p></p> <ul> <li>then a cartesian product is made across the parameters of all parametrization marks found on any item in the closure (including parameters of the test itself), So for <code>test_1</code> the cartesian product is <code>&lt;ie&gt; x &lt;ia&gt; x &lt;ib&gt;</code> while for <code>test_2</code> it is <code>&lt;ie&gt; x &lt;ia&gt; x &lt;i2&gt;</code>. This is why both tests result in having 8 variants being called (see details in the test ids above).</li> </ul>"},{"location":"unions_theory/#2-extension-to-fixture-unions","title":"2. Extension to fixture unions.","text":"<p>A fixture union is by definition a fixture that is parametrized to alternately depend on other fixtures. We will represent this in the figures with a special dashed orange arrow, to remind that a special parameter is associated with the selection of which arrow is activated. </p> <p>Let's consider the following modification of the above example, where we introduce two \"unions\": one as an explicit fixture <code>u</code>, and the other implicitly created by using <code>fixture_ref</code>s in the parametrization of <code>b</code>.</p> <p></p> <p>We can create such a configuration with a slight modification to the above example:</p> <pre><code>from pytest_cases import fixture, parametrize, fixture_ref, fixture_union\n\n(... same as above ...)\n\n@fixture\n@parametrize(ib=['x', 'z'])\n@parametrize(ub=(fixture_ref(a), fixture_ref(c)), idstyle=\"explicit\")\ndef b(ub, ib):\n    return \"b%s\" % ib + ub\n\nu = fixture_union(\"u\", (a, b), idstyle=\"explicit\")\n\ndef test_1(u):\n    pass\n</code></pre> <p>Note the <code>idstyle=\"explicit\"</code> keyword arguments, that will help us get more details in the test ids.</p> <p>Calling <code>pytest</code> yields:</p> <pre><code>============================= test session starts =============================\ncollecting ... collected 24 items\n\ntest_doc_fixture_graph_union.py::test_2[ie=-1-ia=0-i2=x] PASSED          [  4%]\ntest_doc_fixture_graph_union.py::test_2[ie=-1-ia=0-i2=z] PASSED          [  8%]\ntest_doc_fixture_graph_union.py::test_2[ie=-1-ia=1-i2=x] PASSED          [ 12%]\ntest_doc_fixture_graph_union.py::test_2[ie=-1-ia=1-i2=z] PASSED          [ 16%]\ntest_doc_fixture_graph_union.py::test_2[ie=1-ia=0-i2=x] PASSED           [ 20%]\ntest_doc_fixture_graph_union.py::test_2[ie=1-ia=0-i2=z] PASSED           [ 25%]\ntest_doc_fixture_graph_union.py::test_2[ie=1-ia=1-i2=x] PASSED           [ 29%]\ntest_doc_fixture_graph_union.py::test_2[ie=1-ia=1-i2=z] PASSED           [ 33%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\a-ia=0] PASSED           [ 37%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\a-ia=1] PASSED           [ 41%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\b-ib=x-ub\\a-ia=0] PASSED [ 45%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\b-ib=x-ub\\a-ia=1] PASSED [ 50%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\b-ib=x-ub\\c]  PASSED     [ 54%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\b-ib=z-ub\\a-ia=0] PASSED [ 58%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\b-ib=z-ub\\a-ia=1] PASSED [ 62%]\ntest_doc_fixture_graph_union.py::test_1[ie=-1-u\\b-ib=z-ub\\c] PASSED      [ 66%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\a-ia=0] PASSED            [ 70%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\a-ia=1] PASSED            [ 75%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\b-ib=x-ub\\a-ia=0] PASSED  [ 79%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\b-ib=x-ub\\a-ia=1] PASSED  [ 83%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\b-ib=x-ub\\c] PASSED       [ 87%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\b-ib=z-ub\\a-ia=0] PASSED  [ 91%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\b-ib=z-ub\\a-ia=1] PASSED  [ 95%]\ntest_doc_fixture_graph_union.py::test_1[ie=1-u\\b-ib=z-ub\\c] PASSED       [100%]\n\n======================== 24 passed, 1 warning in 0.30s ========================\n</code></pre> <p>Now 24 tests were created ! <code>test_2</code> still has 8 runs, which is normal as it does not depend on any union fixture. Let's try to understand what happened to parametrization of <code>test_1</code>. It is actually fairly simple: </p> <ul> <li> <p>first a global fixture closure is created as usual, consisting in <code>{u, a, b, c, d, e}</code></p> </li> <li> <p>then for each union fixture in <code>test_1</code>'s closure, starting from the bottom of the graph, we generate several closures by activating each of the arrows in turn. We progress upwards through the graph of remaining dependencies for each alternative:</p> <ul> <li>first <code>u</code> is used to split between subgraphs <code>u\\a</code> and <code>u\\b</code></li> <li>subgraph <code>u\\a</code> does not contain any union. Its final closure is <code>{u, a, c, d, e}</code></li> <li> <p>for subgraph <code>u\\b</code> there is another union. So a new split is generated:</p> <ul> <li>subgraph <code>u\\b-ub\\a</code> does not contain any union. Its final closure is <code>{u, b, a, c, d, e}</code></li> <li>subgraph <code>u\\b-ub\\c</code> does not contain any union. Its final closure is <code>{u, b, c, e}</code></li> </ul> </li> </ul> </li> </ul> <p>So the result consists in 3 alternate fixture closures for <code>test_1</code>:</p> <p></p> <ul> <li> <p>finally, as usual, for each closure a cartesian product is made across the parameters of all parametrization marks found on any item in the closure (including parameters of the test itself), So </p> <ul> <li>for <code>test_1</code> alternative <code>u\\a</code>, the cartesian product is <code>&lt;ie&gt; x &lt;ia&gt;</code>  (4 tests) </li> <li>for <code>test_1</code> alternative <code>u\\b-ub\\a</code>, the cartesian product is <code>&lt;ie&gt; x &lt;ia&gt; x &lt;ib&gt;</code>  (8 tests) </li> <li>for <code>test_1</code> alternative <code>u\\b-ub\\c</code>, the cartesian product is <code>&lt;ie&gt; x &lt;ib&gt;</code>  (4 tests) </li> <li>for <code>test_2</code> it is <code>&lt;ie&gt; x &lt;ia&gt; x &lt;i2&gt;</code>. (8 tests).</li> </ul> </li> </ul> <p>The total is indeed 4 + 8 + 4 + 8 = 24 tests. Once again the test ids may be used to check that everything is correct, see above.</p>"}]}